{"ast":null,"code":"/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\nconst {\n  Transform\n} = require('stream');\n\nconst ResizeableBuffer = require('./ResizeableBuffer');\n\nconst tab = 9;\nconst nl = 10;\nconst np = 12;\nconst cr = 13;\nconst space = 32;\nconst bom_utf8 = Buffer.from([239, 187, 191]);\n\nclass Parser extends Transform {\n  constructor(opts = {}) {\n    super({ ...{\n        readableObjectMode: true\n      },\n      ...opts\n    });\n    const options = {}; // Merge with user options\n\n    for (let opt in opts) {\n      options[underscore(opt)] = opts[opt];\n    } // Normalize option `bom`\n\n\n    if (options.bom === undefined || options.bom === null || options.bom === false) {\n      options.bom = false;\n    } else if (options.bom !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_BOM', ['Invalid option bom:', 'bom must be true,', `got ${JSON.stringify(options.bom)}`]);\n    } // Normalize option `cast`\n\n\n    let fnCastField = null;\n\n    if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === '') {\n      options.cast = undefined;\n    } else if (typeof options.cast === 'function') {\n      fnCastField = options.cast;\n      options.cast = true;\n    } else if (options.cast !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_CAST', ['Invalid option cast:', 'cast must be true or a function,', `got ${JSON.stringify(options.cast)}`]);\n    } // Normalize option `cast_date`\n\n\n    if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === '') {\n      options.cast_date = false;\n    } else if (options.cast_date === true) {\n      options.cast_date = function (value) {\n        const date = Date.parse(value);\n        return !isNaN(date) ? new Date(date) : value;\n      };\n    } else if (typeof options.cast_date !== 'function') {\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', ['Invalid option cast_date:', 'cast_date must be true or a function,', `got ${JSON.stringify(options.cast_date)}`]);\n    } // Normalize option `columns`\n\n\n    let fnFirstLineToHeaders = null;\n\n    if (options.columns === true) {\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined;\n    } else if (typeof options.columns === 'function') {\n      fnFirstLineToHeaders = options.columns;\n      options.columns = true;\n    } else if (Array.isArray(options.columns)) {\n      options.columns = normalizeColumnsArray(options.columns);\n    } else if (options.columns === undefined || options.columns === null || options.columns === false) {\n      options.columns = false;\n    } else {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', ['Invalid option columns:', 'expect an object, a function or true,', `got ${JSON.stringify(options.columns)}`]);\n    } // Normalize option `comment`\n\n\n    if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === '') {\n      options.comment = null;\n    } else {\n      if (typeof options.comment === 'string') {\n        options.comment = Buffer.from(options.comment);\n      }\n\n      if (!Buffer.isBuffer(options.comment)) {\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', ['Invalid option comment:', 'comment must be a buffer or a string,', `got ${JSON.stringify(options.comment)}`]);\n      }\n    } // Normalize option `delimiter`\n\n\n    const delimiter_json = JSON.stringify(options.delimiter);\n    if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n\n    if (options.delimiter.length === 0) {\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', `got ${delimiter_json}`]);\n    }\n\n    options.delimiter = options.delimiter.map(function (delimiter) {\n      if (delimiter === undefined || delimiter === null || delimiter === false) {\n        return Buffer.from(',');\n      }\n\n      if (typeof delimiter === 'string') {\n        delimiter = Buffer.from(delimiter);\n      }\n\n      if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', `got ${delimiter_json}`]);\n      }\n\n      return delimiter;\n    }); // Normalize option `escape`\n\n    if (options.escape === undefined || options.escape === null) {\n      options.escape = Buffer.from('\"');\n    } else if (typeof options.escape === 'string') {\n      options.escape = Buffer.from(options.escape);\n    }\n\n    if (!Buffer.isBuffer(options.escape)) {\n      throw new Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`);\n    } else if (options.escape.length !== 1) {\n      throw new Error(`Invalid Option Length: escape must be one character, got ${options.escape.length}`);\n    } else {\n      options.escape = options.escape[0];\n    } // Normalize option `from`\n\n\n    if (options.from === undefined || options.from === null) {\n      options.from = 1;\n    } else {\n      if (typeof options.from === 'string' && /\\d+/.test(options.from)) {\n        options.from = parseInt(options.from);\n      }\n\n      if (Number.isInteger(options.from)) {\n        if (options.from < 0) {\n          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);\n        }\n      } else {\n        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);\n      }\n    } // Normalize option `from_line`\n\n\n    if (options.from_line === undefined || options.from_line === null) {\n      options.from_line = 1;\n    } else {\n      if (typeof options.from_line === 'string' && /\\d+/.test(options.from_line)) {\n        options.from_line = parseInt(options.from_line);\n      }\n\n      if (Number.isInteger(options.from_line)) {\n        if (options.from_line <= 0) {\n          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);\n        }\n      } else {\n        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);\n      }\n    } // Normalize option `info`\n\n\n    if (options.info === undefined || options.info === null || options.info === false) {\n      options.info = false;\n    } else if (options.info !== true) {\n      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);\n    } // Normalize option `max_record_size`\n\n\n    if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {\n      options.max_record_size = 0;\n    } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {// Great, nothing to do\n    } else if (typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)) {\n      options.max_record_size = parseInt(options.max_record_size);\n    } else {\n      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);\n    } // Normalize option `objname`\n\n\n    if (options.objname === undefined || options.objname === null || options.objname === false) {\n      options.objname = undefined;\n    } else if (Buffer.isBuffer(options.objname)) {\n      if (options.objname.length === 0) {\n        throw new Error(`Invalid Option: objname must be a non empty buffer`);\n      }\n\n      options.objname = options.objname.toString();\n    } else if (typeof options.objname === 'string') {\n      if (options.objname.length === 0) {\n        throw new Error(`Invalid Option: objname must be a non empty string`);\n      } // Great, nothing to do\n\n    } else {\n      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);\n    } // Normalize option `on_record`\n\n\n    if (options.on_record === undefined || options.on_record === null) {\n      options.on_record = undefined;\n    } else if (typeof options.on_record !== 'function') {\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', ['Invalid option `on_record`:', 'expect a function,', `got ${JSON.stringify(options.on_record)}`]);\n    } // Normalize option `quote`\n\n\n    if (options.quote === null || options.quote === false || options.quote === '') {\n      options.quote = null;\n    } else {\n      if (options.quote === undefined || options.quote === true) {\n        options.quote = Buffer.from('\"');\n      } else if (typeof options.quote === 'string') {\n        options.quote = Buffer.from(options.quote);\n      }\n\n      if (!Buffer.isBuffer(options.quote)) {\n        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);\n      } else if (options.quote.length !== 1) {\n        throw new Error(`Invalid Option Length: quote must be one character, got ${options.quote.length}`);\n      } else {\n        options.quote = options.quote[0];\n      }\n    } // Normalize option `raw`\n\n\n    if (options.raw === undefined || options.raw === null || options.raw === false) {\n      options.raw = false;\n    } else if (options.raw !== true) {\n      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);\n    } // Normalize option `record_delimiter`\n\n\n    if (!options.record_delimiter) {\n      options.record_delimiter = [];\n    } else if (!Array.isArray(options.record_delimiter)) {\n      options.record_delimiter = [options.record_delimiter];\n    }\n\n    options.record_delimiter = options.record_delimiter.map(function (rd) {\n      if (typeof rd === 'string') {\n        rd = Buffer.from(rd);\n      }\n\n      return rd;\n    }); // Normalize option `relax`\n\n    if (typeof options.relax === 'boolean') {// Great, nothing to do\n    } else if (options.relax === undefined || options.relax === null) {\n      options.relax = false;\n    } else {\n      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`);\n    } // Normalize option `relax_column_count`\n\n\n    if (typeof options.relax_column_count === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count === undefined || options.relax_column_count === null) {\n      options.relax_column_count = false;\n    } else {\n      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);\n    }\n\n    if (typeof options.relax_column_count_less === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {\n      options.relax_column_count_less = false;\n    } else {\n      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);\n    }\n\n    if (typeof options.relax_column_count_more === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {\n      options.relax_column_count_more = false;\n    } else {\n      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);\n    } // Normalize option `skip_empty_lines`\n\n\n    if (typeof options.skip_empty_lines === 'boolean') {// Great, nothing to do\n    } else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {\n      options.skip_empty_lines = false;\n    } else {\n      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);\n    } // Normalize option `skip_lines_with_empty_values`\n\n\n    if (typeof options.skip_lines_with_empty_values === 'boolean') {// Great, nothing to do\n    } else if (options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null) {\n      options.skip_lines_with_empty_values = false;\n    } else {\n      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`);\n    } // Normalize option `skip_lines_with_error`\n\n\n    if (typeof options.skip_lines_with_error === 'boolean') {// Great, nothing to do\n    } else if (options.skip_lines_with_error === undefined || options.skip_lines_with_error === null) {\n      options.skip_lines_with_error = false;\n    } else {\n      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`);\n    } // Normalize option `rtrim`\n\n\n    if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {\n      options.rtrim = false;\n    } else if (options.rtrim !== true) {\n      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);\n    } // Normalize option `ltrim`\n\n\n    if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {\n      options.ltrim = false;\n    } else if (options.ltrim !== true) {\n      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);\n    } // Normalize option `trim`\n\n\n    if (options.trim === undefined || options.trim === null || options.trim === false) {\n      options.trim = false;\n    } else if (options.trim !== true) {\n      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);\n    } // Normalize options `trim`, `ltrim` and `rtrim`\n\n\n    if (options.trim === true && opts.ltrim !== false) {\n      options.ltrim = true;\n    } else if (options.ltrim !== true) {\n      options.ltrim = false;\n    }\n\n    if (options.trim === true && opts.rtrim !== false) {\n      options.rtrim = true;\n    } else if (options.rtrim !== true) {\n      options.rtrim = false;\n    } // Normalize option `to`\n\n\n    if (options.to === undefined || options.to === null) {\n      options.to = -1;\n    } else {\n      if (typeof options.to === 'string' && /\\d+/.test(options.to)) {\n        options.to = parseInt(options.to);\n      }\n\n      if (Number.isInteger(options.to)) {\n        if (options.to <= 0) {\n          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);\n        }\n      } else {\n        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);\n      }\n    } // Normalize option `to_line`\n\n\n    if (options.to_line === undefined || options.to_line === null) {\n      options.to_line = -1;\n    } else {\n      if (typeof options.to_line === 'string' && /\\d+/.test(options.to_line)) {\n        options.to_line = parseInt(options.to_line);\n      }\n\n      if (Number.isInteger(options.to_line)) {\n        if (options.to_line <= 0) {\n          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);\n        }\n      } else {\n        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);\n      }\n    }\n\n    this.info = {\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    };\n    this.options = options;\n    this.state = {\n      bomSkipped: false,\n      castField: fnCastField,\n      commenting: false,\n      enabled: options.from_line === 1,\n      escaping: false,\n      escapeIsQuote: options.escape === options.quote,\n      expectedRecordLength: options.columns === null ? 0 : options.columns.length,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      info: Object.assign({}, this.info),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map(v => v.length)),\n      trimChars: [Buffer.from(' ')[0], Buffer.from('\\t')[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    };\n  } // Implementation of `Transform._transform`\n\n\n  _transform(buf, encoding, callback) {\n    if (this.state.stop === true) {\n      return;\n    }\n\n    const err = this.__parse(buf, false);\n\n    if (err !== undefined) {\n      this.state.stop = true;\n    }\n\n    callback(err);\n  } // Implementation of `Transform._flush`\n\n\n  _flush(callback) {\n    if (this.state.stop === true) {\n      return;\n    }\n\n    const err = this.__parse(undefined, true);\n\n    callback(err);\n  } // Central parser implementation\n\n\n  __parse(nextBuf, end) {\n    const {\n      bom,\n      comment,\n      escape,\n      from_line,\n      info,\n      ltrim,\n      max_record_size,\n      quote,\n      raw,\n      relax,\n      rtrim,\n      skip_empty_lines,\n      to,\n      to_line\n    } = this.options;\n    let {\n      record_delimiter\n    } = this.options;\n    const {\n      bomSkipped,\n      previousBuf,\n      rawBuffer,\n      escapeIsQuote\n    } = this.state;\n    let buf;\n\n    if (previousBuf === undefined) {\n      if (nextBuf === undefined) {\n        // Handle empty string\n        this.push(null);\n        return;\n      } else {\n        buf = nextBuf;\n      }\n    } else if (previousBuf !== undefined && nextBuf === undefined) {\n      buf = previousBuf;\n    } else {\n      buf = Buffer.concat([previousBuf, nextBuf]);\n    } // Handle UTF BOM\n\n\n    if (bomSkipped === false) {\n      if (bom === false) {\n        this.state.bomSkipped = true;\n      } else if (buf.length < 3) {\n        // No enough data\n        if (end === false) {\n          // Wait for more data\n          this.state.previousBuf = buf;\n          return;\n        } // skip BOM detect because data length < 3\n\n      } else {\n        if (bom_utf8.compare(buf, 0, 3) === 0) {\n          // Skip BOM\n          buf = buf.slice(3);\n        }\n\n        this.state.bomSkipped = true;\n      }\n    }\n\n    const bufLen = buf.length;\n    let pos;\n\n    for (pos = 0; pos < bufLen; pos++) {\n      // Ensure we get enough space to look ahead\n      // There should be a way to move this out of the loop\n      if (this.__needMoreData(pos, bufLen, end)) {\n        break;\n      }\n\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n\n        if (info === true && this.state.record.length === 0 && this.state.field.length === 0 && this.state.wasQuoting === false) {\n          this.state.info = Object.assign({}, this.info);\n        }\n\n        this.state.wasRowDelimiter = false;\n      }\n\n      if (to_line !== -1 && this.info.lines > to_line) {\n        this.state.stop = true;\n        this.push(null);\n        return;\n      } // Auto discovery of record_delimiter, unix, mac and windows supported\n\n\n      if (this.state.quoting === false && record_delimiter.length === 0) {\n        const record_delimiterCount = this.__autoDiscoverRowDelimiter(buf, pos);\n\n        if (record_delimiterCount) {\n          record_delimiter = this.options.record_delimiter;\n        }\n      }\n\n      const chr = buf[pos];\n\n      if (raw === true) {\n        rawBuffer.append(chr);\n      }\n\n      if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n        this.state.wasRowDelimiter = true;\n      } // Previous char was a valid escape char\n      // treat the current char as a regular char\n\n\n      if (this.state.escaping === true) {\n        this.state.escaping = false;\n      } else {\n        // Escape is only active inside quoted fields\n        // We are quoting, the char is an escape chr and there is a chr to escape\n        if (this.state.quoting === true && chr === escape && pos + 1 < bufLen) {\n          if (escapeIsQuote) {\n            if (buf[pos + 1] === quote) {\n              this.state.escaping = true;\n              continue;\n            }\n          } else {\n            this.state.escaping = true;\n            continue;\n          }\n        } // Not currently escaping and chr is a quote\n        // TODO: need to compare bytes instead of single char\n\n\n        if (this.state.commenting === false && chr === quote) {\n          if (this.state.quoting === true) {\n            const nextChr = buf[pos + 1];\n\n            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr); // const isNextChrComment = nextChr === comment\n\n\n            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + 1, nextChr);\n\n            const isNextChrDelimiter = this.__isDelimiter(nextChr, buf, pos + 1);\n\n            const isNextChrRowDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRowDelimiter(buf, pos + 1) : this.__isRecordDelimiter(nextChr, buf, pos + 1); // Escape a quote\n            // Treat next char as a regular character\n            // TODO: need to compare bytes instead of single char\n\n            if (chr === escape && nextChr === quote) {\n              pos++;\n            } else if (!nextChr || isNextChrDelimiter || isNextChrRowDelimiter || isNextChrComment || isNextChrTrimable) {\n              this.state.quoting = false;\n              this.state.wasQuoting = true;\n              continue;\n            } else if (relax === false) {\n              const err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', `got \"${String.fromCharCode(nextChr)}\"`, `at line ${this.info.lines}`, 'instead of delimiter, row delimiter, trimable character', '(if activated) or comment'], this.__context()));\n\n              if (err !== undefined) return err;\n            } else {\n              this.state.quoting = false;\n              this.state.wasQuoting = true; // continue\n\n              this.state.field.prepend(quote);\n            }\n          } else {\n            if (this.state.field.length !== 0) {\n              // In relax mode, treat opening quote preceded by chrs as regular\n              if (relax === false) {\n                const err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', `a quote is found inside a field at line ${this.info.lines}`], this.__context(), {\n                  field: this.state.field\n                }));\n\n                if (err !== undefined) return err;\n              }\n            } else {\n              this.state.quoting = true;\n              continue;\n            }\n          }\n        }\n\n        if (this.state.quoting === false) {\n          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n\n          if (recordDelimiterLength !== 0) {\n            // Do not emit comments which take a full line\n            const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n\n            if (skipCommentLine) {\n              this.info.comment_lines++; // Skip full comment line\n            } else {\n              // Skip if line is empty and skip_empty_lines activated\n              if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                this.info.empty_lines++;\n                pos += recordDelimiterLength - 1;\n                continue;\n              } // Activate records emition if above from_line\n\n\n              if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                this.state.enabled = true;\n\n                this.__resetField();\n\n                this.__resetRow();\n\n                pos += recordDelimiterLength - 1;\n                continue;\n              } else {\n                const errField = this.__onField();\n\n                if (errField !== undefined) return errField;\n\n                const errRecord = this.__onRow();\n\n                if (errRecord !== undefined) return errRecord;\n              }\n\n              if (to !== -1 && this.info.records >= to) {\n                this.state.stop = true;\n                this.push(null);\n                return;\n              }\n            }\n\n            this.state.commenting = false;\n            pos += recordDelimiterLength - 1;\n            continue;\n          }\n\n          if (this.state.commenting) {\n            continue;\n          }\n\n          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n\n          if (commentCount !== 0) {\n            this.state.commenting = true;\n            continue;\n          }\n\n          let delimiterLength = this.__isDelimiter(chr, buf, pos);\n\n          if (delimiterLength !== 0) {\n            const errField = this.__onField();\n\n            if (errField !== undefined) return errField;\n            pos += delimiterLength - 1;\n            continue;\n          }\n        }\n      }\n\n      if (this.state.commenting === false) {\n        if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n          const err = this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', `of ${max_record_size}`, `at line ${this.info.lines}`], this.__context()));\n\n          if (err !== undefined) return err;\n        }\n      }\n\n      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr); // rtrim in non quoting is handle in __onField\n\n      const rappend = rtrim === false || this.state.wasQuoting === false;\n\n      if (lappend === true && rappend === true) {\n        this.state.field.append(chr);\n      } else if (rtrim === true && !this.__isCharTrimable(chr)) {\n        const err = this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', `at line ${this.info.lines}`], this.__context()));\n\n        if (err !== undefined) return err;\n      }\n    }\n\n    if (end === true) {\n      // Ensure we are not ending in a quoting state\n      if (this.state.quoting === true) {\n        const err = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', `the parsing is finished with an opening quote at line ${this.info.lines}`], this.__context()));\n\n        if (err !== undefined) return err;\n      } else {\n        // Skip last line if it has no characters\n        if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n          const errField = this.__onField();\n\n          if (errField !== undefined) return errField;\n\n          const errRecord = this.__onRow();\n\n          if (errRecord !== undefined) return errRecord;\n        } else if (this.state.wasRowDelimiter === true) {\n          this.info.empty_lines++;\n        } else if (this.state.commenting === true) {\n          this.info.comment_lines++;\n        }\n      }\n    } else {\n      this.state.previousBuf = buf.slice(pos);\n    }\n\n    if (this.state.wasRowDelimiter === true) {\n      this.info.lines++;\n      this.state.wasRowDelimiter = false;\n    }\n  } // Helper to test if a character is a space or a line delimiter\n\n\n  __isCharTrimable(chr) {\n    return chr === space || chr === tab || chr === cr || chr === nl || chr === np;\n  }\n\n  __onRow() {\n    const {\n      columns,\n      info,\n      from,\n      relax_column_count,\n      relax_column_count_less,\n      relax_column_count_more,\n      raw,\n      skip_lines_with_empty_values\n    } = this.options;\n    const {\n      enabled,\n      record\n    } = this.state;\n\n    if (enabled === false) {\n      return this.__resetRow();\n    } // Convert the first line into column names\n\n\n    const recordLength = record.length;\n\n    if (columns === true) {\n      if (isRecordEmpty(record)) {\n        this.__resetRow();\n\n        return;\n      }\n\n      return this.__firstLineToColumns(record);\n    }\n\n    if (columns === false && this.info.records === 0) {\n      this.state.expectedRecordLength = recordLength;\n    }\n\n    if (recordLength !== this.state.expectedRecordLength) {\n      if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n        this.info.invalid_field_length++;\n      } else {\n        if (columns === false) {\n          const err = this.__error(new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', ['Invalid Record Length:', `expect ${this.state.expectedRecordLength},`, `got ${recordLength} on line ${this.info.lines}`], this.__context(), {\n            record: record\n          }));\n\n          if (err !== undefined) return err;\n        } else {\n          const err = this.__error( // CSV_INVALID_RECORD_LENGTH_DONT_MATCH_COLUMNS\n          new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', ['Invalid Record Length:', `columns length is ${columns.length},`, // rename columns\n          `got ${recordLength} on line ${this.info.lines}`], this.__context(), {\n            record: record\n          }));\n\n          if (err !== undefined) return err;\n        }\n      }\n    }\n\n    if (skip_lines_with_empty_values === true) {\n      if (isRecordEmpty(record)) {\n        this.__resetRow();\n\n        return;\n      }\n    }\n\n    if (this.state.recordHasError === true) {\n      this.__resetRow();\n\n      this.state.recordHasError = false;\n      return;\n    }\n\n    this.info.records++;\n\n    if (from === 1 || this.info.records >= from) {\n      if (columns !== false) {\n        const obj = {}; // Transform record array to an object\n\n        for (let i = 0, l = record.length; i < l; i++) {\n          if (columns[i] === undefined || columns[i].disabled) continue;\n          obj[columns[i].name] = record[i];\n        }\n\n        const {\n          objname\n        } = this.options;\n\n        if (objname === undefined) {\n          if (raw === true || info === true) {\n            const err = this.__push(Object.assign({\n              record: obj\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString()\n            } : {}, info === true ? {\n              info: this.state.info\n            } : {}));\n\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(obj);\n\n            if (err) {\n              return err;\n            }\n          }\n        } else {\n          if (raw === true || info === true) {\n            const err = this.__push(Object.assign({\n              record: [obj[objname], obj]\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString()\n            } : {}, info === true ? {\n              info: this.state.info\n            } : {}));\n\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push([obj[objname], obj]);\n\n            if (err) {\n              return err;\n            }\n          }\n        }\n      } else {\n        if (raw === true || info === true) {\n          const err = this.__push(Object.assign({\n            record: record\n          }, raw === true ? {\n            raw: this.state.rawBuffer.toString()\n          } : {}, info === true ? {\n            info: this.state.info\n          } : {}));\n\n          if (err) {\n            return err;\n          }\n        } else {\n          const err = this.__push(record);\n\n          if (err) {\n            return err;\n          }\n        }\n      }\n    }\n\n    this.__resetRow();\n  }\n\n  __firstLineToColumns(record) {\n    const {\n      firstLineToHeaders\n    } = this.state;\n\n    try {\n      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n\n      if (!Array.isArray(headers)) {\n        return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', `got ${JSON.stringify(headers)}`], this.__context(), {\n          headers: headers\n        }));\n      }\n\n      const normalizedHeaders = normalizeColumnsArray(headers);\n      this.state.expectedRecordLength = normalizedHeaders.length;\n      this.options.columns = normalizedHeaders;\n\n      this.__resetRow();\n\n      return;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  __resetRow() {\n    if (this.options.raw === true) {\n      this.state.rawBuffer.reset();\n    }\n\n    this.state.record = [];\n    this.state.record_length = 0;\n  }\n\n  __onField() {\n    const {\n      cast,\n      rtrim,\n      max_record_size\n    } = this.options;\n    const {\n      enabled,\n      wasQuoting\n    } = this.state; // Short circuit for the from_line options\n\n    if (enabled === false) {\n      /* this.options.columns !== true && */\n      return this.__resetField();\n    }\n\n    let field = this.state.field.toString();\n\n    if (rtrim === true && wasQuoting === false) {\n      field = field.trimRight();\n    }\n\n    if (cast === true) {\n      const [err, f] = this.__cast(field);\n\n      if (err !== undefined) return err;\n      field = f;\n    }\n\n    this.state.record.push(field); // Increment record length if record size must not exceed a limit\n\n    if (max_record_size !== 0 && typeof field === 'string') {\n      this.state.record_length += field.length;\n    }\n\n    this.__resetField();\n  }\n\n  __resetField() {\n    this.state.field.reset();\n    this.state.wasQuoting = false;\n  }\n\n  __push(record) {\n    const {\n      on_record\n    } = this.options;\n\n    if (on_record !== undefined) {\n      const context = this.__context();\n\n      try {\n        record = on_record.call(null, record, context);\n      } catch (err) {\n        return err;\n      }\n\n      if (record === undefined || record === null) {\n        return;\n      }\n    }\n\n    this.push(record);\n  } // Return a tuple with the error and the casted value\n\n\n  __cast(field) {\n    const {\n      columns,\n      relax_column_count\n    } = this.options;\n    const isColumns = Array.isArray(columns); // Dont loose time calling cast\n    // because the final record is an object\n    // and this field can't be associated to a key present in columns\n\n    if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n      return [undefined, undefined];\n    }\n\n    const context = this.__context();\n\n    if (this.state.castField !== null) {\n      try {\n        return [undefined, this.state.castField.call(null, field, context)];\n      } catch (err) {\n        return [err];\n      }\n    }\n\n    if (this.__isFloat(field)) {\n      return [undefined, parseFloat(field)];\n    } else if (this.options.cast_date !== false) {\n      return [undefined, this.options.cast_date.call(null, field, context)];\n    }\n\n    return [undefined, field];\n  } // Keep it in case we implement the `cast_int` option\n  // __isInt(value){\n  //   // return Number.isInteger(parseInt(value))\n  //   // return !isNaN( parseInt( obj ) );\n  //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n  // }\n\n\n  __isFloat(value) {\n    return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n  }\n\n  __compareBytes(sourceBuf, targetBuf, pos, firtByte) {\n    if (sourceBuf[0] !== firtByte) return 0;\n    const sourceLength = sourceBuf.length;\n\n    for (let i = 1; i < sourceLength; i++) {\n      if (sourceBuf[i] !== targetBuf[pos + i]) return 0;\n    }\n\n    return sourceLength;\n  }\n\n  __needMoreData(i, bufLen, end) {\n    if (end) {\n      return false;\n    }\n\n    const {\n      comment,\n      delimiter\n    } = this.options;\n    const {\n      quoting,\n      recordDelimiterMaxLength\n    } = this.state;\n    const numOfCharLeft = bufLen - i - 1;\n    const requiredLength = Math.max( // Skip if the remaining buffer smaller than comment\n    comment ? comment.length : 0, // Skip if the remaining buffer smaller than row delimiter\n    recordDelimiterMaxLength, // Skip if the remaining buffer can be row delimiter following the closing quote\n    // 1 is for quote.length\n    quoting ? 1 + recordDelimiterMaxLength : 0, // Skip if the remaining buffer can be delimiter\n    delimiter.length, // Skip if the remaining buffer can be escape sequence\n    // 1 is for escape.length\n    1);\n    return numOfCharLeft < requiredLength;\n  }\n\n  __isDelimiter(chr, buf, pos) {\n    const {\n      delimiter\n    } = this.options;\n\n    loop1: for (let i = 0; i < delimiter.length; i++) {\n      const del = delimiter[i];\n\n      if (del[0] === chr) {\n        for (let j = 1; j < del.length; j++) {\n          if (del[j] !== buf[pos + j]) continue loop1;\n        }\n\n        return del.length;\n      }\n    }\n\n    return 0;\n  }\n\n  __isRecordDelimiter(chr, buf, pos) {\n    const {\n      record_delimiter\n    } = this.options;\n    const recordDelimiterLength = record_delimiter.length;\n\n    loop1: for (let i = 0; i < recordDelimiterLength; i++) {\n      const rd = record_delimiter[i];\n      const rdLength = rd.length;\n\n      if (rd[0] !== chr) {\n        continue;\n      }\n\n      for (let j = 1; j < rdLength; j++) {\n        if (rd[j] !== buf[pos + j]) {\n          continue loop1;\n        }\n      }\n\n      return rd.length;\n    }\n\n    return 0;\n  }\n\n  __autoDiscoverRowDelimiter(buf, pos) {\n    const chr = buf[pos];\n\n    if (chr === cr) {\n      if (buf[pos + 1] === nl) {\n        this.options.record_delimiter.push(Buffer.from('\\r\\n'));\n        this.state.recordDelimiterMaxLength = 2;\n        return 2;\n      } else {\n        this.options.record_delimiter.push(Buffer.from('\\r'));\n        this.state.recordDelimiterMaxLength = 1;\n        return 1;\n      }\n    } else if (chr === nl) {\n      this.options.record_delimiter.push(Buffer.from('\\n'));\n      this.state.recordDelimiterMaxLength = 1;\n      return 1;\n    }\n\n    return 0;\n  }\n\n  __error(msg) {\n    const {\n      skip_lines_with_error\n    } = this.options;\n    const err = typeof msg === 'string' ? new Error(msg) : msg;\n\n    if (skip_lines_with_error) {\n      this.state.recordHasError = true;\n      this.emit('skip', err);\n      return undefined;\n    } else {\n      return err;\n    }\n  }\n\n  __context() {\n    const {\n      columns\n    } = this.options;\n    const isColumns = Array.isArray(columns);\n    return {\n      column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n      empty_lines: this.info.empty_lines,\n      header: columns === true,\n      index: this.state.record.length,\n      invalid_field_length: this.info.invalid_field_length,\n      quoting: this.state.wasQuoting,\n      lines: this.info.lines,\n      records: this.info.records\n    };\n  }\n\n}\n\nconst parse = function () {\n  let data, options, callback;\n\n  for (let i in arguments) {\n    const argument = arguments[i];\n    const type = typeof argument;\n\n    if (data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', `got ${JSON.stringify(argument)} at index ${i}`]);\n    }\n  }\n\n  const parser = new Parser(options);\n\n  if (callback) {\n    const records = options === undefined || options.objname === undefined ? [] : {};\n    parser.on('readable', function () {\n      let record;\n\n      while ((record = this.read()) !== null) {\n        if (options === undefined || options.objname === undefined) {\n          records.push(record);\n        } else {\n          records[record[0]] = record[1];\n        }\n      }\n    });\n    parser.on('error', function (err) {\n      callback(err, undefined, parser.info);\n    });\n    parser.on('end', function () {\n      callback(undefined, records, parser.info);\n    });\n  }\n\n  if (data !== undefined) {\n    // Give a chance for events to be registered later\n    if (typeof setImmediate === 'function') {\n      setImmediate(function () {\n        parser.write(data);\n        parser.end();\n      });\n    } else {\n      parser.write(data);\n      parser.end();\n    }\n  }\n\n  return parser;\n};\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if (Array.isArray(message)) message = message.join(' ');\n    super(message);\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n\n    this.code = code;\n\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n\n}\n\nparse.Parser = Parser;\nparse.CsvError = CsvError;\nmodule.exports = parse;\n\nconst underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nconst isObject = function (obj) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nconst isRecordEmpty = function (record) {\n  return record.every(field => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst normalizeColumnsArray = function (columns) {\n  const normalizedColumns = [];\n\n  for (let i = 0, l = columns.length; i < l; i++) {\n    const column = columns[i];\n\n    if (column === undefined || column === null || column === false) {\n      normalizedColumns[i] = {\n        disabled: true\n      };\n    } else if (typeof column === 'string') {\n      normalizedColumns[i] = {\n        name: column\n      };\n    } else if (isObject(column)) {\n      if (typeof column.name !== 'string') {\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', ['Option columns missing name:', `property \"name\" is required at position ${i}`, 'when column is an object literal']);\n      }\n\n      normalizedColumns[i] = column;\n    } else {\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', ['Invalid column definition:', 'expect a string or a literal object,', `got ${JSON.stringify(column)} at position ${i}`]);\n    }\n  }\n\n  return normalizedColumns;\n};","map":{"version":3,"sources":["/Users/shukan/Google Drive/Personal Projects/arxived/node_modules/csv-parse/lib/index.js"],"names":["Transform","require","ResizeableBuffer","tab","nl","np","cr","space","bom_utf8","Buffer","from","Parser","constructor","opts","readableObjectMode","options","opt","underscore","bom","undefined","CsvError","JSON","stringify","fnCastField","cast","cast_date","value","date","Date","parse","isNaN","fnFirstLineToHeaders","columns","Array","isArray","normalizeColumnsArray","comment","isBuffer","delimiter_json","delimiter","length","map","escape","Error","test","parseInt","Number","isInteger","from_line","info","max_record_size","objname","toString","on_record","quote","raw","record_delimiter","rd","relax","relax_column_count","relax_column_count_less","relax_column_count_more","skip_empty_lines","skip_lines_with_empty_values","skip_lines_with_error","rtrim","ltrim","trim","to","to_line","comment_lines","empty_lines","invalid_field_length","lines","records","state","bomSkipped","castField","commenting","enabled","escaping","escapeIsQuote","expectedRecordLength","field","firstLineToHeaders","Object","assign","previousBuf","quoting","stop","rawBuffer","record","recordHasError","record_length","recordDelimiterMaxLength","Math","max","v","trimChars","wasQuoting","wasRowDelimiter","_transform","buf","encoding","callback","err","__parse","_flush","nextBuf","end","push","concat","compare","slice","bufLen","pos","__needMoreData","record_delimiterCount","__autoDiscoverRowDelimiter","chr","append","nextChr","isNextChrTrimable","__isCharTrimable","isNextChrComment","__compareBytes","isNextChrDelimiter","__isDelimiter","isNextChrRowDelimiter","__isRecordDelimiter","__error","String","fromCharCode","__context","prepend","recordDelimiterLength","skipCommentLine","__resetField","__resetRow","errField","__onField","errRecord","__onRow","commentCount","delimiterLength","lappend","rappend","recordLength","isRecordEmpty","__firstLineToColumns","obj","i","l","disabled","name","__push","headers","call","normalizedHeaders","reset","trimRight","f","__cast","context","isColumns","__isFloat","parseFloat","sourceBuf","targetBuf","firtByte","sourceLength","numOfCharLeft","requiredLength","loop1","del","j","rdLength","msg","emit","column","header","index","data","arguments","argument","type","isObject","parser","on","read","setImmediate","write","code","message","contexts","join","captureStackTrace","key","module","exports","str","replace","_","match","toLowerCase","every","normalizedColumns"],"mappings":"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","sourcesContent":["\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\n\nconst { Transform } = require('stream')\nconst ResizeableBuffer = require('./ResizeableBuffer')\n\nconst tab = 9\nconst nl = 10\nconst np = 12\nconst cr = 13\nconst space = 32\nconst bom_utf8 = Buffer.from([239, 187, 191])\n\nclass Parser extends Transform {\n  constructor(opts = {}){\n    super({...{readableObjectMode: true}, ...opts})\n    const options = {}\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      throw new CsvError('CSV_INVALID_OPTION_BOM', [\n        'Invalid option bom:', 'bom must be true,',\n        `got ${JSON.stringify(options.bom)}`\n      ])\n    }\n    // Normalize option `cast`\n    let fnCastField = null\n    if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n      options.cast = undefined\n    }else if(typeof options.cast === 'function'){\n      fnCastField = options.cast\n      options.cast = true\n    }else if(options.cast !== true){\n      throw new CsvError('CSV_INVALID_OPTION_CAST', [\n        'Invalid option cast:', 'cast must be true or a function,',\n        `got ${JSON.stringify(options.cast)}`\n      ])\n    }\n    // Normalize option `cast_date`\n    if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n      options.cast_date = false\n    }else if(options.cast_date === true){\n      options.cast_date = function(value){\n        const date = Date.parse(value)\n        return !isNaN(date) ? new Date(date) : value\n      }\n    }else if(typeof options.cast_date !== 'function'){\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [\n        'Invalid option cast_date:', 'cast_date must be true or a function,',\n        `got ${JSON.stringify(options.cast_date)}`\n      ])\n    }\n    // Normalize option `columns`\n    let fnFirstLineToHeaders = null\n    if(options.columns === true){\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined\n    }else if(typeof options.columns === 'function'){\n      fnFirstLineToHeaders = options.columns\n      options.columns = true\n    }else if(Array.isArray(options.columns)){\n      options.columns = normalizeColumnsArray(options.columns)\n    }else if(options.columns === undefined || options.columns === null || options.columns === false){\n      options.columns = false\n    }else{\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [\n        'Invalid option columns:',\n        'expect an object, a function or true,',\n        `got ${JSON.stringify(options.columns)}`\n      ])\n    }\n    // Normalize option `comment`\n    if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n      options.comment = null\n    }else{\n      if(typeof options.comment === 'string'){\n        options.comment = Buffer.from(options.comment)\n      }\n      if(!Buffer.isBuffer(options.comment)){\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n          'Invalid option comment:',\n          'comment must be a buffer or a string,',\n          `got ${JSON.stringify(options.comment)}`\n        ])\n      }\n    }\n    // Normalize option `delimiter`\n    const delimiter_json = JSON.stringify(options.delimiter)\n    if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter]\n    if(options.delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ])\n    }\n    options.delimiter = options.delimiter.map(function(delimiter){\n      if(delimiter === undefined || delimiter === null || delimiter === false){\n        return Buffer.from(',')\n      }\n      if(typeof delimiter === 'string'){\n        delimiter = Buffer.from(delimiter)\n      }\n      if( !Buffer.isBuffer(delimiter) || delimiter.length === 0){\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n          'Invalid option delimiter:',\n          'delimiter must be a non empty string or buffer or array of string|buffer,',\n          `got ${delimiter_json}`\n        ])\n      }\n      return delimiter\n    })\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === null){\n      options.escape = Buffer.from('\"')\n    }else if(typeof options.escape === 'string'){\n      options.escape = Buffer.from(options.escape)\n    }\n    if(!Buffer.isBuffer(options.escape)){\n      throw new Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)\n    }else if(options.escape.length !== 1){\n      throw new Error(`Invalid Option Length: escape must be one character, got ${options.escape.length}`)\n    }else{\n      options.escape = options.escape[0]\n    }\n    // Normalize option `from`\n    if(options.from === undefined || options.from === null){\n      options.from = 1\n    }else{\n      if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n        options.from = parseInt(options.from)\n      }\n      if(Number.isInteger(options.from)){\n        if(options.from < 0){\n          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`)\n      }\n    }\n    // Normalize option `from_line`\n    if(options.from_line === undefined || options.from_line === null){\n      options.from_line = 1\n    }else{\n      if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n        options.from_line = parseInt(options.from_line)\n      }\n      if(Number.isInteger(options.from_line)){\n        if(options.from_line <= 0){\n          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`)\n      }\n    }\n    // Normalize option `info`\n    if(options.info === undefined || options.info === null || options.info === false){\n      options.info = false\n    }else if(options.info !== true){\n      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`)\n    }\n    // Normalize option `max_record_size`\n    if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n      options.max_record_size = 0\n    }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n      // Great, nothing to do\n    }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n      options.max_record_size = parseInt(options.max_record_size)\n    }else{\n      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`)\n    }\n    // Normalize option `objname`\n    if(options.objname === undefined || options.objname === null || options.objname === false){\n      options.objname = undefined\n    }else if(Buffer.isBuffer(options.objname)){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty buffer`)\n      }\n      options.objname = options.objname.toString()\n    }else if(typeof options.objname === 'string'){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty string`)\n      }\n      // Great, nothing to do\n    }else{\n      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`)\n    }\n    // Normalize option `on_record`\n    if(options.on_record === undefined || options.on_record === null){\n      options.on_record = undefined\n    }else if(typeof options.on_record !== 'function'){\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [\n        'Invalid option `on_record`:',\n        'expect a function,',\n        `got ${JSON.stringify(options.on_record)}`\n      ])\n    }\n    // Normalize option `quote`\n    if(options.quote === null || options.quote === false || options.quote === ''){\n      options.quote = null\n    }else{\n      if(options.quote === undefined || options.quote === true){\n        options.quote = Buffer.from('\"')\n      }else if(typeof options.quote === 'string'){\n        options.quote = Buffer.from(options.quote)\n      }\n      if(!Buffer.isBuffer(options.quote)){\n        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`)\n      }else if(options.quote.length !== 1){\n        throw new Error(`Invalid Option Length: quote must be one character, got ${options.quote.length}`)\n      }else{\n        options.quote = options.quote[0]\n      }\n    }\n    // Normalize option `raw`\n    if(options.raw === undefined || options.raw === null || options.raw === false){\n      options.raw = false\n    }else if(options.raw !== true){\n      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`)\n    }\n    // Normalize option `record_delimiter`\n    if(!options.record_delimiter){\n      options.record_delimiter = []\n    }else if(!Array.isArray(options.record_delimiter)){\n      options.record_delimiter = [options.record_delimiter]\n    }\n    options.record_delimiter = options.record_delimiter.map( function(rd){\n      if(typeof rd === 'string'){\n        rd = Buffer.from(rd)\n      }\n      return rd\n    })\n    // Normalize option `relax`\n    if(typeof options.relax === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax === undefined || options.relax === null){\n      options.relax = false\n    }else{\n      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`)\n    }\n    // Normalize option `relax_column_count`\n    if(typeof options.relax_column_count === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n      options.relax_column_count = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`)\n    }\n    if(typeof options.relax_column_count_less === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n      options.relax_column_count_less = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`)\n    }\n    if(typeof options.relax_column_count_more === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n      options.relax_column_count_more = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`)\n    }\n    // Normalize option `skip_empty_lines`\n    if(typeof options.skip_empty_lines === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n      options.skip_empty_lines = false\n    }else{\n      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`)\n    }\n    // Normalize option `skip_lines_with_empty_values`\n    if(typeof options.skip_lines_with_empty_values === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null){\n      options.skip_lines_with_empty_values = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`)\n    }\n    // Normalize option `skip_lines_with_error`\n    if(typeof options.skip_lines_with_error === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_error === undefined || options.skip_lines_with_error === null){\n      options.skip_lines_with_error = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`)\n    }\n    // Normalize option `rtrim`\n    if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n      options.rtrim = false\n    }else if(options.rtrim !== true){\n      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`)\n    }\n    // Normalize option `ltrim`\n    if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n      options.ltrim = false\n    }else if(options.ltrim !== true){\n      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`)\n    }\n    // Normalize option `trim`\n    if(options.trim === undefined || options.trim === null || options.trim === false){\n      options.trim = false\n    }else if(options.trim !== true){\n      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`)\n    }\n    // Normalize options `trim`, `ltrim` and `rtrim`\n    if(options.trim === true && opts.ltrim !== false){\n      options.ltrim = true\n    }else if(options.ltrim !== true){\n      options.ltrim = false\n    }\n    if(options.trim === true && opts.rtrim !== false){\n      options.rtrim = true\n    }else if(options.rtrim !== true){\n      options.rtrim = false\n    }\n    // Normalize option `to`\n    if(options.to === undefined || options.to === null){\n      options.to = -1\n    }else{\n      if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n        options.to = parseInt(options.to)\n      }\n      if(Number.isInteger(options.to)){\n        if(options.to <= 0){\n          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`)\n      }\n    }\n    // Normalize option `to_line`\n    if(options.to_line === undefined || options.to_line === null){\n      options.to_line = -1\n    }else{\n      if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n        options.to_line = parseInt(options.to_line)\n      }\n      if(Number.isInteger(options.to_line)){\n        if(options.to_line <= 0){\n          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`)\n      }\n    }\n    this.info = {\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    }\n    this.options = options\n    this.state = {\n      bomSkipped: false,\n      castField: fnCastField,\n      commenting: false,\n      enabled: options.from_line === 1,\n      escaping: false,\n      escapeIsQuote: options.escape === options.quote,\n      expectedRecordLength: options.columns === null ? 0 : options.columns.length,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      info: Object.assign({}, this.info),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map( (v) => v.length)),\n      trimChars: [Buffer.from(' ')[0], Buffer.from('\\t')[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    }\n  }\n  // Implementation of `Transform._transform`\n  _transform(buf, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(buf, false)\n    if(err !== undefined){\n      this.state.stop = true\n    }\n    callback(err)\n  }\n  // Implementation of `Transform._flush`\n  _flush(callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(undefined, true)\n    callback(err)\n  }\n  // Central parser implementation\n  __parse(nextBuf, end){\n    const {bom, comment, escape, from_line, info, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line} = this.options\n    let {record_delimiter} = this.options\n    const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state\n    let buf\n    if(previousBuf === undefined){\n      if(nextBuf === undefined){\n        // Handle empty string\n        this.push(null)\n        return\n      }else{\n        buf = nextBuf\n      }\n    }else if(previousBuf !== undefined && nextBuf === undefined){\n      buf = previousBuf\n    }else{\n      buf = Buffer.concat([previousBuf, nextBuf])\n    }\n    // Handle UTF BOM\n    if(bomSkipped === false){\n      if(bom === false){\n        this.state.bomSkipped = true\n      }else if(buf.length < 3){\n        // No enough data\n        if(end === false){\n          // Wait for more data\n          this.state.previousBuf = buf\n          return\n        }\n        // skip BOM detect because data length < 3\n      }else{\n        if(bom_utf8.compare(buf, 0, 3) === 0){\n          // Skip BOM\n          buf = buf.slice(3)\n        }\n        this.state.bomSkipped = true\n      }\n    }\n    const bufLen = buf.length\n    let pos\n    for(pos = 0; pos < bufLen; pos++){\n      // Ensure we get enough space to look ahead\n      // There should be a way to move this out of the loop\n      if(this.__needMoreData(pos, bufLen, end)){\n        break\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++\n        if(info === true && this.state.record.length === 0 && this.state.field.length === 0 && this.state.wasQuoting === false){\n          this.state.info = Object.assign({}, this.info)\n        }\n        this.state.wasRowDelimiter = false\n      }\n      if(to_line !== -1 && this.info.lines > to_line){\n        this.state.stop = true\n        this.push(null)\n        return\n      }\n      // Auto discovery of record_delimiter, unix, mac and windows supported\n      if(this.state.quoting === false && record_delimiter.length === 0){\n        const record_delimiterCount = this.__autoDiscoverRowDelimiter(buf, pos)\n        if(record_delimiterCount){\n          record_delimiter = this.options.record_delimiter\n        }\n      }\n      const chr = buf[pos]\n      if(raw === true){\n        rawBuffer.append(chr)\n      }\n      if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false ){\n        this.state.wasRowDelimiter = true\n      }\n      // Previous char was a valid escape char\n      // treat the current char as a regular char\n      if(this.state.escaping === true){\n        this.state.escaping = false\n      }else{\n        // Escape is only active inside quoted fields\n        // We are quoting, the char is an escape chr and there is a chr to escape\n        if(this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if(escapeIsQuote){\n            if(buf[pos+1] === quote){\n              this.state.escaping = true\n              continue\n            }\n          }else{\n            this.state.escaping = true\n            continue\n          }\n        }\n        // Not currently escaping and chr is a quote\n        // TODO: need to compare bytes instead of single char\n        if(this.state.commenting === false && chr === quote){\n          if(this.state.quoting === true){\n            const nextChr = buf[pos+1]\n            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr)\n            // const isNextChrComment = nextChr === comment\n            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+1, nextChr)\n            const isNextChrDelimiter = this.__isDelimiter(nextChr, buf, pos+1)\n            const isNextChrRowDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRowDelimiter(buf, pos+1) : this.__isRecordDelimiter(nextChr, buf, pos+1)\n            // Escape a quote\n            // Treat next char as a regular character\n            // TODO: need to compare bytes instead of single char\n            if(chr === escape && nextChr === quote){\n              pos++\n            }else if(!nextChr || isNextChrDelimiter || isNextChrRowDelimiter || isNextChrComment || isNextChrTrimable){\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              continue\n            }else if(relax === false){\n              const err = this.__error(\n                new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                  'Invalid Closing Quote:',\n                  `got \"${String.fromCharCode(nextChr)}\"`,\n                  `at line ${this.info.lines}`,\n                  'instead of delimiter, row delimiter, trimable character',\n                  '(if activated) or comment',\n                ], this.__context())\n              )\n              if(err !== undefined) return err\n            }else{\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              // continue\n              this.state.field.prepend(quote)\n            }\n          }else{\n            if(this.state.field.length !== 0){\n              // In relax mode, treat opening quote preceded by chrs as regular\n              if( relax === false ){\n                const err = this.__error(\n                  new CsvError('INVALID_OPENING_QUOTE', [\n                    'Invalid Opening Quote:',\n                    `a quote is found inside a field at line ${this.info.lines}`,\n                  ], this.__context(), {\n                    field: this.state.field,\n                  })\n                )\n                if(err !== undefined) return err\n              }\n            }else{\n              this.state.quoting = true\n              continue\n            }\n          }\n        }\n        if(this.state.quoting === false){\n          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos)\n          if(recordDelimiterLength !== 0){\n            // Do not emit comments which take a full line\n            const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0)\n            if(skipCommentLine){\n              this.info.comment_lines++\n              // Skip full comment line\n            }else{\n              // Skip if line is empty and skip_empty_lines activated\n              if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                this.info.empty_lines++\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              // Activate records emition if above from_line\n              if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0 ) >= from_line){\n                this.state.enabled = true\n                this.__resetField()\n                this.__resetRow()\n                pos += recordDelimiterLength - 1\n                continue\n              }else{\n                const errField = this.__onField()\n                if(errField !== undefined) return errField\n                const errRecord = this.__onRow()\n                if(errRecord !== undefined) return errRecord\n              }\n              if(to !== -1 && this.info.records >= to){\n                this.state.stop = true\n                this.push(null)\n                return\n              }\n            }\n            this.state.commenting = false\n            pos += recordDelimiterLength - 1\n            continue\n          }\n          if(this.state.commenting){\n            continue\n          }\n          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr)\n          if(commentCount !== 0){\n            this.state.commenting = true\n            continue\n          }\n          let delimiterLength = this.__isDelimiter(chr, buf, pos)\n          if(delimiterLength !== 0){\n            const errField = this.__onField()\n            if(errField !== undefined) return errField\n            pos += delimiterLength - 1\n            continue\n          }\n        }\n      }\n      if(this.state.commenting === false){\n        if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n          const err = this.__error(\n            new CsvError('CSV_MAX_RECORD_SIZE', [\n              'Max Record Size:',\n              'record exceed the maximum number of tolerated bytes',\n              `of ${max_record_size}`,\n              `at line ${this.info.lines}`,\n            ], this.__context())\n          )\n          if(err !== undefined) return err\n        }\n      }\n\n      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr)\n      // rtrim in non quoting is handle in __onField\n      const rappend = rtrim === false || this.state.wasQuoting === false\n      if( lappend === true && rappend === true ){\n        this.state.field.append(chr)\n      }else if(rtrim === true && !this.__isCharTrimable(chr)){\n        const err = this.__error(\n          new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n            'Invalid Closing Quote:',\n            'found non trimable byte after quote',\n            `at line ${this.info.lines}`,\n          ], this.__context())\n        )\n        if(err !== undefined) return err\n      }\n    }\n    if(end === true){\n      // Ensure we are not ending in a quoting state\n      if(this.state.quoting === true){\n        const err = this.__error(\n          new CsvError('CSV_QUOTE_NOT_CLOSED', [\n            'Quote Not Closed:',\n            `the parsing is finished with an opening quote at line ${this.info.lines}`,\n          ], this.__context())\n        )\n        if(err !== undefined) return err\n      }else{\n        // Skip last line if it has no characters\n        if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n          const errField = this.__onField()\n          if(errField !== undefined) return errField\n          const errRecord = this.__onRow()\n          if(errRecord !== undefined) return errRecord\n        }else if(this.state.wasRowDelimiter === true){\n          this.info.empty_lines++\n        }else if(this.state.commenting === true){\n          this.info.comment_lines++\n        }\n      }\n    }else{\n      this.state.previousBuf = buf.slice(pos)\n    }\n    if(this.state.wasRowDelimiter === true){\n      this.info.lines++\n      this.state.wasRowDelimiter = false\n    }\n  }\n  // Helper to test if a character is a space or a line delimiter\n  __isCharTrimable(chr){\n    return chr === space || chr === tab || chr === cr || chr === nl || chr === np\n  }\n  __onRow(){\n    const {columns, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_lines_with_empty_values} = this.options\n    const {enabled, record} = this.state\n    if(enabled === false){\n      return this.__resetRow()\n    }\n    // Convert the first line into column names\n    const recordLength = record.length\n    if(columns === true){\n      if(isRecordEmpty(record)){\n        this.__resetRow()\n        return\n      }\n      return this.__firstLineToColumns(record)\n    }\n    if(columns === false && this.info.records === 0){\n      this.state.expectedRecordLength = recordLength\n    }\n    if(recordLength !== this.state.expectedRecordLength){\n      if(relax_column_count === true || \n        (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n        (relax_column_count_more === true && recordLength > this.state.expectedRecordLength) ){\n        this.info.invalid_field_length++\n      }else{\n        if(columns === false){\n          const err = this.__error(\n            new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', [\n              'Invalid Record Length:',\n              `expect ${this.state.expectedRecordLength},`,\n              `got ${recordLength} on line ${this.info.lines}`,\n            ], this.__context(), {\n              record: record,\n            })\n          )\n          if(err !== undefined) return err\n        }else{\n          const err = this.__error(\n            // CSV_INVALID_RECORD_LENGTH_DONT_MATCH_COLUMNS\n            new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', [\n              'Invalid Record Length:',\n              `columns length is ${columns.length},`, // rename columns\n              `got ${recordLength} on line ${this.info.lines}`,\n            ], this.__context(), {\n              record: record,\n            })\n          )\n          if(err !== undefined) return err\n        }\n      }\n    }\n    if(skip_lines_with_empty_values === true){\n      if(isRecordEmpty(record)){\n        this.__resetRow()\n        return\n      }\n    }\n    if(this.state.recordHasError === true){\n      this.__resetRow()\n      this.state.recordHasError = false\n      return\n    }\n    this.info.records++\n    if(from === 1 || this.info.records >= from){\n      if(columns !== false){\n        const obj = {}\n        // Transform record array to an object\n        for(let i = 0, l = record.length; i < l; i++){\n          if(columns[i] === undefined || columns[i].disabled) continue\n          obj[columns[i].name] = record[i]\n        }\n        const {objname} = this.options\n        if(objname === undefined){\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString()}: {}),\n              (info === true ? {info: this.state.info}: {})\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push(obj)\n            if(err){\n              return err\n            }\n          }\n        }else{\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: [obj[objname], obj]},\n              raw === true ? {raw: this.state.rawBuffer.toString()}: {},\n              info === true ? {info: this.state.info}: {}\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push([obj[objname], obj])\n            if(err){\n              return err\n            }\n          }\n        }\n      }else{\n        if(raw === true || info === true){\n          const err = this.__push(Object.assign(\n            {record: record},\n            raw === true ? {raw: this.state.rawBuffer.toString()}: {},\n            info === true ? {info: this.state.info}: {}\n          ))\n          if(err){\n            return err\n          }\n        }else{\n          const err = this.__push(record)\n          if(err){\n            return err\n          }\n        }\n      }\n    }\n    this.__resetRow()\n  }\n  __firstLineToColumns(record){\n    const {firstLineToHeaders} = this.state\n    try{\n      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record)\n      if(!Array.isArray(headers)){\n        return this.__error(\n          new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n            'Invalid Column Mapping:',\n            'expect an array from column function,',\n            `got ${JSON.stringify(headers)}`\n          ], this.__context(), {\n            headers: headers,\n          })\n        )\n      }\n      const normalizedHeaders = normalizeColumnsArray(headers)\n      this.state.expectedRecordLength = normalizedHeaders.length\n      this.options.columns = normalizedHeaders\n      this.__resetRow()\n      return\n    }catch(err){\n      return err\n    }\n  }\n  __resetRow(){\n    if(this.options.raw === true){\n      this.state.rawBuffer.reset()\n    }\n    this.state.record = []\n    this.state.record_length = 0\n  }\n  __onField(){\n    const {cast, rtrim, max_record_size} = this.options\n    const {enabled, wasQuoting} = this.state\n    // Short circuit for the from_line options\n    if(enabled === false){ /* this.options.columns !== true && */\n      return this.__resetField()\n    }\n    let field = this.state.field.toString()\n    if(rtrim === true && wasQuoting === false){\n      field = field.trimRight()\n    }\n    if(cast === true){\n      const [err, f] = this.__cast(field)\n      if(err !== undefined) return err\n      field = f\n    }\n    this.state.record.push(field)\n    // Increment record length if record size must not exceed a limit\n    if(max_record_size !== 0 && typeof field === 'string'){\n      this.state.record_length += field.length\n    }\n    this.__resetField()\n  }\n  __resetField(){\n    this.state.field.reset()\n    this.state.wasQuoting = false\n  }\n  __push(record){\n    const {on_record} = this.options\n    if(on_record !== undefined){\n      const context = this.__context()\n      try{\n        record = on_record.call(null, record, context)\n      }catch(err){\n        return err\n      }\n      if(record === undefined || record === null){ return }\n    }\n    this.push(record)\n  }\n  // Return a tuple with the error and the casted value\n  __cast(field){\n    const {columns, relax_column_count} = this.options\n    const isColumns = Array.isArray(columns)\n    // Dont loose time calling cast\n    // because the final record is an object\n    // and this field can't be associated to a key present in columns\n    if( isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length ){\n      return [undefined, undefined]\n    }\n    const context = this.__context()\n    if(this.state.castField !== null){\n      try{\n        return [undefined, this.state.castField.call(null, field, context)]\n      }catch(err){\n        return [err]\n      }\n    }\n    if(this.__isFloat(field)){\n      return [undefined, parseFloat(field)]\n    }else if(this.options.cast_date !== false){\n      return [undefined, this.options.cast_date.call(null, field, context)]\n    }\n    return [undefined, field]\n  }\n  // Keep it in case we implement the `cast_int` option\n  // __isInt(value){\n  //   // return Number.isInteger(parseInt(value))\n  //   // return !isNaN( parseInt( obj ) );\n  //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n  // }\n  __isFloat(value){\n    return (value - parseFloat( value ) + 1) >= 0 // Borrowed from jquery\n  }\n  __compareBytes(sourceBuf, targetBuf, pos, firtByte){\n    if(sourceBuf[0] !== firtByte) return 0\n    const sourceLength = sourceBuf.length\n    for(let i = 1; i < sourceLength; i++){\n      if(sourceBuf[i] !== targetBuf[pos+i]) return 0\n    }\n    return sourceLength\n  }\n  __needMoreData(i, bufLen, end){\n    if(end){\n      return false\n    }\n    const {comment, delimiter} = this.options\n    const {quoting, recordDelimiterMaxLength} = this.state\n    const numOfCharLeft = bufLen - i - 1\n    const requiredLength = Math.max(\n      // Skip if the remaining buffer smaller than comment\n      comment ? comment.length : 0,\n      // Skip if the remaining buffer smaller than row delimiter\n      recordDelimiterMaxLength,\n      // Skip if the remaining buffer can be row delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? (1 + recordDelimiterMaxLength) : 0,\n      // Skip if the remaining buffer can be delimiter\n      delimiter.length,\n      // Skip if the remaining buffer can be escape sequence\n      // 1 is for escape.length\n      1\n    )\n    return numOfCharLeft < requiredLength\n  }\n  __isDelimiter(chr, buf, pos){\n    const {delimiter} = this.options\n    loop1: for(let i = 0; i < delimiter.length; i++){\n      const del = delimiter[i]\n      if(del[0] === chr){\n        for(let j = 1; j < del.length; j++){\n          if(del[j] !== buf[pos+j]) continue loop1\n        }\n        return del.length\n      }\n    }\n    return 0\n  }\n  __isRecordDelimiter(chr, buf, pos){\n    const {record_delimiter} = this.options\n    const recordDelimiterLength = record_delimiter.length\n    loop1: for(let i = 0; i < recordDelimiterLength; i++){\n      const rd = record_delimiter[i]\n      const rdLength = rd.length\n      if(rd[0] !== chr){\n        continue\n      }\n      for(let j = 1; j < rdLength; j++){\n        if(rd[j] !== buf[pos+j]){\n          continue loop1\n        }\n      }\n      return rd.length\n    }\n    return 0\n  }\n  __autoDiscoverRowDelimiter(buf, pos){\n    const chr = buf[pos]\n    if(chr === cr){\n      if(buf[pos+1] === nl){\n        this.options.record_delimiter.push(Buffer.from('\\r\\n'))\n        this.state.recordDelimiterMaxLength = 2\n        return 2\n      }else{\n        this.options.record_delimiter.push(Buffer.from('\\r'))\n        this.state.recordDelimiterMaxLength = 1\n        return 1\n      }\n    }else if(chr === nl){\n      this.options.record_delimiter.push(Buffer.from('\\n'))\n      this.state.recordDelimiterMaxLength = 1\n      return 1\n    }\n    return 0\n  }\n  __error(msg){\n    const {skip_lines_with_error} = this.options\n    const err = typeof msg === 'string' ? new Error(msg) : msg\n    if(skip_lines_with_error){\n      this.state.recordHasError = true\n      this.emit('skip', err)\n      return undefined\n    }else{\n      return err\n    }\n  }\n  __context(){\n    const {columns} = this.options\n    const isColumns = Array.isArray(columns)\n    return {\n      column: isColumns === true ?\n        ( columns.length > this.state.record.length ?\n          columns[this.state.record.length].name :\n          null\n        ) :\n        this.state.record.length,\n      empty_lines: this.info.empty_lines,\n      header: columns === true,\n      index: this.state.record.length,\n      invalid_field_length: this.info.invalid_field_length,\n      quoting: this.state.wasQuoting,\n      lines: this.info.lines,\n      records: this.info.records\n    }\n  }\n}\n\nconst parse = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ])\n    }\n  }\n  const parser = new Parser(options)\n  if(callback){\n    const records = options === undefined || options.objname === undefined ? [] : {}\n    parser.on('readable', function(){\n      let record\n      while((record = this.read()) !== null){\n        if(options === undefined || options.objname === undefined){\n          records.push(record)\n        }else{\n          records[record[0]] = record[1]\n        }\n      }\n    })\n    parser.on('error', function(err){\n      callback(err, undefined, parser.info)\n    })\n    parser.on('end', function(){\n      callback(undefined, records, parser.info)\n    })\n  }\n  if(data !== undefined){\n    // Give a chance for events to be registered later\n    if(typeof setImmediate === 'function'){\n      setImmediate(function(){\n        parser.write(data)\n        parser.end()\n      })\n    }else{\n      parser.write(data)\n      parser.end()\n    }\n  }\n  return parser\n}\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ')\n    super(message)\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError)\n    }\n    this.code = code\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key]\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value))\n      }\n    }\n  }\n}\n\nparse.Parser = Parser\n\nparse.CsvError = CsvError\n\nmodule.exports = parse\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase()\n  })\n}\n\nconst isObject = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj))\n}\n\nconst isRecordEmpty = function(record){\n  return record.every( (field) => field == null || field.toString && field.toString().trim() === '' )\n}\n\nconst normalizeColumnsArray = function(columns){\n  const normalizedColumns = [];\n  for(let i = 0, l = columns.length; i < l; i++){\n    const column = columns[i]\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true }\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column }\n    }else if(isObject(column)){\n      if(typeof column.name !== 'string'){\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [\n          'Option columns missing name:',\n          `property \"name\" is required at position ${i}`,\n          'when column is an object literal'\n        ])\n      }\n      normalizedColumns[i] = column\n    }else{\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [\n        'Invalid column definition:',\n        'expect a string or a literal object,',\n        `got ${JSON.stringify(column)} at position ${i}`\n      ])\n    }\n  }\n  return normalizedColumns;\n}\n"]},"metadata":{},"sourceType":"script"}