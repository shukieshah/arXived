{"ast":null,"code":"'use strict';\n\nconst csv = require('async-csv');\n\nconst fs = require('fs');\n/**\n * Converts an array of objects into a CSV file.\n */\n\n\nclass ObjectsToCsv {\n  /**\n   * Creates a new instance of the object array to csv converter.\n   * @param {object[]} objectArray\n   */\n  constructor(objectArray) {\n    if (!Array.isArray(objectArray)) {\n      throw new Error('The input to objects-to-csv must be an array of objects.');\n    }\n\n    if (objectArray.length > 0) {\n      if (objectArray.some(row => typeof row !== 'object')) {\n        throw new Error('The array must contain objects, not other data types.');\n      }\n    }\n\n    this.data = objectArray;\n  }\n  /**\n   * Saves the CSV file to the specified file.\n   * @param {string} filename - The path and filename of the new CSV file.\n   * @param {object} options - The options for writing to disk.\n   * @param {boolean} [options.append] - Whether to append to file. Default is overwrite (false).\n   * @param {boolean} [options.bom] - Append the BOM mark so that Excel shows\n   * @param {boolean} [options.allColumns] - Whether to check all items for column names or only the first.  Default is the first.\n   * Unicode correctly.\n   */\n\n\n  async toDisk(filename, options) {\n    if (!filename) {\n      throw new Error('Empty filename when trying to write to disk.');\n    }\n\n    let addHeader = false; // If the file didn't exist yet or is empty, add the column headers\n    // as the first line of the file. Do not add it when we are appending\n    // to an existing file.\n\n    const fileNotExists = !fs.existsSync(filename) || fs.statSync(filename).size === 0;\n\n    if (fileNotExists || !options || !options.append) {\n      addHeader = true;\n    }\n\n    const allColumns = options && options.allColumns ? options.allColumns : false;\n    let data = await this.toString(addHeader, allColumns); // Append the BOM mark if requested at the beginning of the file, otherwise\n    // Excel won't show Unicode correctly. The actual BOM mark will be EF BB BF,\n    // see https://stackoverflow.com/a/27975629/6269864 for details.\n\n    if (options && options.bom && fileNotExists) {\n      data = '\\ufeff' + data;\n    }\n\n    if (options && options.append) {\n      return new Promise((resolve, reject) => {\n        fs.appendFile(filename, data, 'utf8', error => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        fs.writeFile(filename, data, 'utf8', error => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    }\n  }\n  /**\n   * Returns the CSV file as string.\n   * @param {boolean} header - If false, omit the first row containing the\n   * column names.\n   * @param {boolean} allColumns - Whether to check all items for column names.\n   *   Uses only the first item if false.\n   * @returns {Promise<string>}\n   */\n\n\n  async toString(header = true, allColumns = false) {\n    return await convert(this.data, header, allColumns);\n  }\n\n}\n/**\n * Private method to run the actual conversion of array of objects to CSV data.\n * @param {object[]} data\n * @param {boolean} header - Whether the first line should contain column headers.\n * @param {boolean} allColumns - Whether to check all items for column names.\n *   Uses only the first item if false.\n * @returns {string}\n */\n\n\nasync function convert(data, header = true, allColumns = false) {\n  if (data.length === 0) {\n    return '';\n  }\n\n  const columnNames = allColumns ? [...data.reduce((columns, row) => {\n    // check each object to compile a full list of column names\n    Object.keys(row).map(rowKey => columns.add(rowKey));\n    return columns;\n  }, new Set())] : Object.keys(data[0]); // just figure out columns from the first item in array\n\n  if (allColumns) {\n    columnNames.sort(); // for predictable order of columns\n  } // This will hold data in the format that `async-csv` can accept, i.e.\n  // an array of arrays.\n\n\n  let csvInput = [];\n\n  if (header) {\n    csvInput.push(columnNames);\n  } // Add all other rows:\n\n\n  csvInput.push(...data.map(row => columnNames.map(column => row[column])));\n  return await csv.stringify(csvInput);\n}\n\nmodule.exports = ObjectsToCsv;","map":{"version":3,"sources":["/Users/shukan/Google Drive/Personal Projects/arxived/node_modules/objects-to-csv/index.js"],"names":["csv","require","fs","ObjectsToCsv","constructor","objectArray","Array","isArray","Error","length","some","row","data","toDisk","filename","options","addHeader","fileNotExists","existsSync","statSync","size","append","allColumns","toString","bom","Promise","resolve","reject","appendFile","error","writeFile","header","convert","columnNames","reduce","columns","Object","keys","map","rowKey","add","Set","sort","csvInput","push","column","stringify","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst csv = require('async-csv');\nconst fs = require('fs');\n\n/**\n * Converts an array of objects into a CSV file.\n */\nclass ObjectsToCsv {\n  /**\n   * Creates a new instance of the object array to csv converter.\n   * @param {object[]} objectArray\n   */\n  constructor(objectArray) {\n    if (!Array.isArray(objectArray)) {\n      throw new Error('The input to objects-to-csv must be an array of objects.');\n    }\n\n    if (objectArray.length > 0) {\n      if (objectArray.some(row => typeof row !== 'object')) {\n        throw new Error('The array must contain objects, not other data types.');\n      }\n    }\n\n    this.data = objectArray;\n  }\n\n  /**\n   * Saves the CSV file to the specified file.\n   * @param {string} filename - The path and filename of the new CSV file.\n   * @param {object} options - The options for writing to disk.\n   * @param {boolean} [options.append] - Whether to append to file. Default is overwrite (false).\n   * @param {boolean} [options.bom] - Append the BOM mark so that Excel shows\n   * @param {boolean} [options.allColumns] - Whether to check all items for column names or only the first.  Default is the first.\n   * Unicode correctly.\n   */\n  async toDisk(filename, options) {\n    if (!filename) {\n      throw new Error('Empty filename when trying to write to disk.');\n    }\n\n    let addHeader = false;\n\n    // If the file didn't exist yet or is empty, add the column headers\n    // as the first line of the file. Do not add it when we are appending\n    // to an existing file.\n    const fileNotExists = !fs.existsSync(filename) || fs.statSync(filename).size === 0;\n    if (fileNotExists || !options || !options.append) {\n      addHeader = true;\n    }\n\n    const allColumns = options && options.allColumns\n      ? options.allColumns\n      : false;\n\n    let data = await this.toString(addHeader, allColumns);\n    // Append the BOM mark if requested at the beginning of the file, otherwise\n    // Excel won't show Unicode correctly. The actual BOM mark will be EF BB BF,\n    // see https://stackoverflow.com/a/27975629/6269864 for details.\n    if (options && options.bom && fileNotExists) {\n      data = '\\ufeff' + data;\n    }\n\n    if (options && options.append) {\n      return new Promise((resolve, reject) => {\n        fs.appendFile(filename, data, 'utf8', (error) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        fs.writeFile(filename, data, 'utf8', (error) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * Returns the CSV file as string.\n   * @param {boolean} header - If false, omit the first row containing the\n   * column names.\n   * @param {boolean} allColumns - Whether to check all items for column names.\n   *   Uses only the first item if false.\n   * @returns {Promise<string>}\n   */\n  async toString(header = true, allColumns = false) {\n    return await convert(this.data, header, allColumns);\n  }\n}\n\n/**\n * Private method to run the actual conversion of array of objects to CSV data.\n * @param {object[]} data\n * @param {boolean} header - Whether the first line should contain column headers.\n * @param {boolean} allColumns - Whether to check all items for column names.\n *   Uses only the first item if false.\n * @returns {string}\n */\nasync function convert(data, header = true, allColumns = false) {\n  if (data.length === 0) {\n    return '';\n  }\n\n  const columnNames =\n    allColumns\n      ? [...data\n        .reduce((columns, row) => { // check each object to compile a full list of column names\n          Object.keys(row).map(rowKey => columns.add(rowKey));\n          return columns;\n        }, new Set())]\n      : Object.keys(data[0]); // just figure out columns from the first item in array\n\n  if (allColumns) {\n    columnNames.sort(); // for predictable order of columns\n  }\n\n  // This will hold data in the format that `async-csv` can accept, i.e.\n  // an array of arrays.\n  let csvInput = [];\n  if (header) {\n    csvInput.push(columnNames);\n  }\n\n  // Add all other rows:\n  csvInput.push(\n    ...data.map(row => columnNames.map(column => row[column])),\n  );\n\n  return await csv.stringify(csvInput);\n}\n\nmodule.exports = ObjectsToCsv;\n"]},"metadata":{},"sourceType":"script"}