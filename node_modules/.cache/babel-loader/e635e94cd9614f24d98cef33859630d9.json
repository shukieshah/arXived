{"ast":null,"code":"/*\nCSV Stringify\n\nPlease look at the [project documentation](https://csv.js.org/stringify/) for\nadditional information.\n*/\nconst {\n  Transform\n} = require('stream');\n\nconst bom_utf8 = Buffer.from([239, 187, 191]);\n\nclass Stringifier extends Transform {\n  constructor(opts = {}) {\n    super({ ...{\n        writableObjectMode: true\n      },\n      ...opts\n    });\n    const options = {};\n    let err; // Merge with user options\n\n    for (let opt in opts) {\n      options[underscore(opt)] = opts[opt];\n    }\n\n    if (err = this.normalize(options)) throw err;\n\n    switch (options.record_delimiter) {\n      case 'auto':\n        options.record_delimiter = null;\n        break;\n\n      case 'unix':\n        options.record_delimiter = \"\\n\";\n        break;\n\n      case 'mac':\n        options.record_delimiter = \"\\r\";\n        break;\n\n      case 'windows':\n        options.record_delimiter = \"\\r\\n\";\n        break;\n\n      case 'ascii':\n        options.record_delimiter = \"\\u001e\";\n        break;\n\n      case 'unicode':\n        options.record_delimiter = \"\\u2028\";\n        break;\n    } // Expose options\n\n\n    this.options = options; // Internal state\n\n    this.state = {\n      stop: false\n    }; // Information\n\n    this.info = {\n      records: 0\n    };\n\n    if (options.bom === true) {\n      this.push(bom_utf8);\n    }\n\n    this;\n  }\n\n  normalize(options) {\n    // Normalize option `bom`\n    if (options.bom === undefined || options.bom === null || options.bom === false) {\n      options.bom = false;\n    } else if (options.bom !== true) {\n      return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', ['option `bom` is optional and must be a boolean value,', `got ${JSON.stringify(options.bom)}`]);\n    } // Normalize option `delimiter`\n\n\n    if (options.delimiter === undefined || options.delimiter === null) {\n      options.delimiter = ',';\n    } else if (Buffer.isBuffer(options.delimiter)) {\n      options.delimiter = options.delimiter.toString();\n    } else if (typeof options.delimiter !== 'string') {\n      return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', ['option `delimiter` must be a buffer or a string,', `got ${JSON.stringify(options.delimiter)}`]);\n    } // Normalize option `quote`\n\n\n    if (options.quote === undefined || options.quote === null) {\n      options.quote = '\"';\n    } else if (options.quote === true) {\n      options.quote = '\"';\n    } else if (options.quote === false) {\n      options.quote = '';\n    } else if (Buffer.isBuffer(options.quote)) {\n      options.quote = options.quote.toString();\n    } else if (typeof options.quote !== 'string') {\n      return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', ['option `quote` must be a boolean, a buffer or a string,', `got ${JSON.stringify(options.quote)}`]);\n    } // Normalize option `quoted`\n\n\n    if (options.quoted === undefined || options.quoted === null) {\n      options.quoted = false;\n    } else {} // todo\n    // Normalize option `quoted_empty`\n\n\n    if (options.quoted_empty === undefined || options.quoted_empty === null) {\n      options.quoted_empty = undefined;\n    } else {} // todo\n    // Normalize option `quoted_match`\n\n\n    if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {\n      options.quoted_match = null;\n    } else if (!Array.isArray(options.quoted_match)) {\n      options.quoted_match = [options.quoted_match];\n    }\n\n    if (options.quoted_match) {\n      for (let quoted_match of options.quoted_match) {\n        const isString = typeof quoted_match === 'string';\n        const isRegExp = quoted_match instanceof RegExp;\n\n        if (!isString && !isRegExp) {\n          return Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`);\n        }\n      }\n    } // Normalize option `quoted_string`\n\n\n    if (options.quoted_string === undefined || options.quoted_string === null) {\n      options.quoted_string = false;\n    } else {} // todo\n    // Normalize option `eof`\n\n\n    if (options.eof === undefined || options.eof === null) {\n      options.eof = true;\n    } else {} // todo\n    // Normalize option `escape`\n\n\n    if (options.escape === undefined || options.escape === null) {\n      options.escape = '\"';\n    } else if (Buffer.isBuffer(options.escape)) {\n      options.escape = options.escape.toString();\n    } else if (typeof options.escape !== 'string') {\n      return Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`);\n    }\n\n    if (options.escape.length > 1) {\n      return Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`);\n    } // Normalize option `header`\n\n\n    if (options.header === undefined || options.header === null) {\n      options.header = false;\n    } else {} // todo\n    // Normalize option `columns`\n\n\n    options.columns = this.normalize_columns(options.columns); // Normalize option `quoted`\n\n    if (options.quoted === undefined || options.quoted === null) {\n      options.quoted = false;\n    } else {} // todo\n    // Normalize option `cast`\n\n\n    if (options.cast === undefined || options.cast === null) {\n      options.cast = {};\n    } else {} // todo\n    // Normalize option cast.bigint\n\n\n    if (options.cast.bigint === undefined || options.cast.bigint === null) {\n      // Cast boolean to string by default\n      options.cast.bigint = value => '' + value;\n    } // Normalize option cast.boolean\n\n\n    if (options.cast.boolean === undefined || options.cast.boolean === null) {\n      // Cast boolean to string by default\n      options.cast.boolean = value => value ? '1' : '';\n    } // Normalize option cast.date\n\n\n    if (options.cast.date === undefined || options.cast.date === null) {\n      // Cast date to timestamp string by default\n      options.cast.date = value => '' + value.getTime();\n    } // Normalize option cast.number\n\n\n    if (options.cast.number === undefined || options.cast.number === null) {\n      // Cast number to string using native casting by default\n      options.cast.number = value => '' + value;\n    } // Normalize option cast.object\n\n\n    if (options.cast.object === undefined || options.cast.object === null) {\n      // Stringify object as JSON by default\n      options.cast.object = value => JSON.stringify(value);\n    } // Normalize option cast.string\n\n\n    if (options.cast.string === undefined || options.cast.string === null) {\n      // Leave string untouched\n      options.cast.string = function (value) {\n        return value;\n      };\n    } // Normalize option `record_delimiter`\n\n\n    if (options.record_delimiter === undefined || options.record_delimiter === null) {\n      options.record_delimiter = '\\n';\n    } else if (Buffer.isBuffer(options.record_delimiter)) {\n      options.record_delimiter = options.record_delimiter.toString();\n    } else if (typeof options.record_delimiter !== 'string') {\n      return Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`);\n    }\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (this.state.stop === true) {\n      return;\n    } // Chunk validation\n\n\n    if (!Array.isArray(chunk) && typeof chunk !== 'object') {\n      this.state.stop = true;\n      return callback(Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`));\n    } // Detect columns from the first record\n\n\n    if (this.info.records === 0) {\n      if (Array.isArray(chunk)) {\n        if (this.options.header === true && !this.options.columns) {\n          this.state.stop = true;\n          return callback(Error('Undiscoverable Columns: header option requires column option or object records'));\n        }\n      } else if (this.options.columns === undefined || this.options.columns === null) {\n        this.options.columns = this.normalize_columns(Object.keys(chunk));\n      }\n    } // Emit the header\n\n\n    if (this.info.records === 0) {\n      this.headers();\n    } // Emit and stringify the record if an object or an array\n\n\n    try {\n      this.emit('record', chunk, this.info.records);\n    } catch (err) {\n      this.state.stop = true;\n      return this.emit('error', err);\n    } // Convert the record into a string\n\n\n    if (this.options.eof) {\n      chunk = this.stringify(chunk);\n\n      if (chunk === undefined) {\n        return;\n      } else {\n        chunk = chunk + this.options.record_delimiter;\n      }\n    } else {\n      chunk = this.stringify(chunk);\n\n      if (chunk === undefined) {\n        return;\n      } else {\n        if (this.options.header || this.info.records) {\n          chunk = this.options.record_delimiter + chunk;\n        }\n      }\n    } // Emit the csv\n\n\n    this.info.records++;\n    this.push(chunk);\n    callback();\n    null;\n  }\n\n  _flush(callback) {\n    if (this.info.records === 0) {\n      this.headers();\n    }\n\n    callback();\n    null;\n  }\n\n  stringify(chunk, chunkIsHeader = false) {\n    if (typeof chunk !== 'object') {\n      return chunk;\n    }\n\n    const {\n      columns,\n      header\n    } = this.options;\n    const record = []; // Record is an array\n\n    if (Array.isArray(chunk)) {\n      // We are getting an array but the user has specified output columns. In\n      // this case, we respect the columns indexes\n      if (columns) {\n        chunk.splice(columns.length);\n      } // Cast record elements\n\n\n      for (let i = 0; i < chunk.length; i++) {\n        const field = chunk[i];\n\n        const [err, value] = this.__cast(field, {\n          index: i,\n          column: i,\n          records: this.info.records,\n          header: chunkIsHeader\n        });\n\n        if (err) {\n          this.emit('error', err);\n          return;\n        }\n\n        record[i] = [value, field];\n      } // Record is a literal object\n\n    } else {\n      if (columns) {\n        for (let i = 0; i < columns.length; i++) {\n          const field = get(chunk, columns[i].key);\n\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: columns[i].key,\n            records: this.info.records,\n            header: chunkIsHeader\n          });\n\n          if (err) {\n            this.emit('error', err);\n            return;\n          }\n\n          record[i] = [value, field];\n        }\n      } else {\n        for (let column of chunk) {\n          const field = chunk[column];\n\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: columns[i].key,\n            records: this.info.records,\n            header: chunkIsHeader\n          });\n\n          if (err) {\n            this.emit('error', err);\n            return;\n          }\n\n          record.push([value, field]);\n        }\n      }\n    }\n\n    let csvrecord = '';\n\n    for (let i = 0; i < record.length; i++) {\n      let options, err;\n      let [value, field] = record[i];\n\n      if (typeof value === \"string\") {\n        options = this.options;\n      } else if (isObject(value)) {\n        // let { value, ...options } = value\n        options = value;\n        value = options.value;\n        delete options.value;\n\n        if (typeof value !== \"string\" && value !== undefined && value !== null) {\n          this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`));\n          return;\n        }\n\n        options = { ...this.options,\n          ...options\n        };\n\n        if (err = this.normalize(options)) {\n          this.emit(\"error\", err);\n          return;\n        }\n      } else if (value === undefined || value === null) {\n        options = this.options;\n      } else {\n        this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`));\n        return;\n      }\n\n      const {\n        delimiter,\n        escape,\n        quote,\n        quoted,\n        quoted_empty,\n        quoted_string,\n        quoted_match,\n        record_delimiter\n      } = options;\n\n      if (value) {\n        if (typeof value !== 'string') {\n          this.emit(\"error\", Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`));\n          return null;\n        }\n\n        const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;\n        const containsQuote = quote !== '' && value.indexOf(quote) >= 0;\n        const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n        const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n        const quotedString = quoted_string && typeof field === 'string';\n        let quotedMatch = quoted_match && quoted_match.filter(quoted_match => {\n          if (typeof quoted_match === 'string') {\n            return value.indexOf(quoted_match) !== -1;\n          } else {\n            return quoted_match.test(value);\n          }\n        });\n        quotedMatch = quotedMatch && quotedMatch.length > 0;\n        const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;\n\n        if (shouldQuote === true && containsEscape === true) {\n          const regexp = escape === '\\\\' ? new RegExp(escape + escape, 'g') : new RegExp(escape, 'g');\n          value = value.replace(regexp, escape + escape);\n        }\n\n        if (containsQuote === true) {\n          const regexp = new RegExp(quote, 'g');\n          value = value.replace(regexp, escape + quote);\n        }\n\n        if (shouldQuote === true) {\n          value = quote + value + quote;\n        }\n\n        csvrecord += value;\n      } else if (quoted_empty === true || field === '' && quoted_string === true && quoted_empty !== false) {\n        csvrecord += quote + quote;\n      }\n\n      if (i !== record.length - 1) {\n        csvrecord += delimiter;\n      }\n    }\n\n    return csvrecord;\n  }\n\n  headers() {\n    if (this.options.header === false) {\n      return;\n    }\n\n    if (this.options.columns === undefined) {\n      return;\n    }\n\n    let headers = this.options.columns.map(column => column.header);\n\n    if (this.options.eof) {\n      headers = this.stringify(headers, true) + this.options.record_delimiter;\n    } else {\n      headers = this.stringify(headers);\n    }\n\n    this.push(headers);\n  }\n\n  __cast(value, context) {\n    const type = typeof value;\n\n    try {\n      if (type === 'string') {\n        // Fine for 99% of the cases\n        return [undefined, this.options.cast.string(value, context)];\n      } else if (type === 'bigint') {\n        return [undefined, this.options.cast.bigint(value, context)];\n      } else if (type === 'number') {\n        return [undefined, this.options.cast.number(value, context)];\n      } else if (type === 'boolean') {\n        return [undefined, this.options.cast.boolean(value, context)];\n      } else if (value instanceof Date) {\n        return [undefined, this.options.cast.date(value, context)];\n      } else if (type === 'object' && value !== null) {\n        return [undefined, this.options.cast.object(value, context)];\n      } else {\n        return [undefined, value, value];\n      }\n    } catch (err) {\n      return [err];\n    }\n  }\n\n  normalize_columns(columns) {\n    if (columns === undefined || columns === null) {\n      return undefined;\n    }\n\n    if (typeof columns !== 'object') {\n      throw Error('Invalid option \"columns\": expect an array or an object');\n    }\n\n    if (!Array.isArray(columns)) {\n      const newcolumns = [];\n\n      for (let k in columns) {\n        newcolumns.push({\n          key: k,\n          header: columns[k]\n        });\n      }\n\n      columns = newcolumns;\n    } else {\n      const newcolumns = [];\n\n      for (let column of columns) {\n        if (typeof column === 'string') {\n          newcolumns.push({\n            key: column,\n            header: column\n          });\n        } else if (typeof column === 'object' && column !== undefined && !Array.isArray(column)) {\n          if (!column.key) {\n            throw Error('Invalid column definition: property \"key\" is required');\n          }\n\n          if (column.header === undefined) {\n            column.header = column.key;\n          }\n\n          newcolumns.push(column);\n        } else {\n          throw Error('Invalid column definition: expect a string or an object');\n        }\n      }\n\n      columns = newcolumns;\n    }\n\n    return columns;\n  }\n\n}\n\nconst stringify = function () {\n  let data, options, callback;\n\n  for (let i in arguments) {\n    const argument = arguments[i];\n    const type = typeof argument;\n\n    if (data === undefined && Array.isArray(argument)) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', `got ${JSON.stringify(argument)} at index ${i}`]);\n    }\n  }\n\n  const stringifier = new Stringifier(options);\n\n  if (callback) {\n    const chunks = [];\n    stringifier.on('readable', function () {\n      let chunk;\n\n      while ((chunk = this.read()) !== null) {\n        chunks.push(chunk);\n      }\n    });\n    stringifier.on('error', function (err) {\n      callback(err);\n    });\n    stringifier.on('end', function () {\n      callback(undefined, chunks.join(''));\n    });\n  }\n\n  if (data !== undefined) {\n    // Give a chance for events to be registered later\n    if (typeof setImmediate === 'function') {\n      setImmediate(function () {\n        for (let record of data) {\n          stringifier.write(record);\n        }\n\n        stringifier.end();\n      });\n    } else {\n      for (let record of data) {\n        stringifier.write(record);\n      }\n\n      stringifier.end();\n    }\n  }\n\n  return stringifier;\n};\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if (Array.isArray(message)) message = message.join(' ');\n    super(message);\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n\n    this.code = code;\n\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n\n}\n\nstringify.Stringifier = Stringifier;\nstringify.CsvError = CsvError;\nmodule.exports = stringify;\n\nconst isObject = function (obj) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nconst underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n}; // Lodash implementation of `get`\n\n\nconst charCodeOfDot = '.'.charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp( // Match anything that isn't a dot or bracket.\n'[^.[\\\\]]+' + '|' + // Or match property names within brackets.\n'\\\\[(?:' + // Match a non-string expression.\n'([^\"\\'][^[]*)' + '|' + // Or match strings (supports escaping characters).\n'([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' + ')\\\\]' + '|' + // Or match \"\" as the space between consecutive dots or empty brackets.\n'(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))', 'g');\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\n\nconst getTag = function (value) {\n  if (!value) value === undefined ? '[object Undefined]' : '[object Null]';\n  return Object.prototype.toString.call(value);\n};\n\nconst isKey = function (value, object) {\n  if (Array.isArray(value)) {\n    return false;\n  }\n\n  const type = typeof value;\n\n  if (type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)) {\n    return true;\n  }\n\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n};\n\nconst isSymbol = function (value) {\n  const type = typeof value;\n  return type === 'symbol' || type === 'object' && value && getTag(value) === '[object Symbol]';\n};\n\nconst stringToPath = function (string) {\n  const result = [];\n\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push('');\n  }\n\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    let key = match;\n\n    if (quote) {\n      key = subString.replace(reEscapeChar, '$1');\n    } else if (expression) {\n      key = expression.trim();\n    }\n\n    result.push(key);\n  });\n  return result;\n};\n\nconst castPath = function (value, object) {\n  if (Array.isArray(value)) {\n    return value;\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value);\n  }\n};\n\nconst toKey = function (value) {\n  if (typeof value === 'string' || isSymbol(value)) return value;\n  const result = `${value}`;\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n};\n\nconst get = function (object, path) {\n  path = castPath(path, object);\n  let index = 0;\n  const length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n\n  return index && index === length ? object : undefined;\n};","map":{"version":3,"sources":["/Users/shukan/Google Drive/Personal Projects/arxived/node_modules/csv-stringify/lib/index.js"],"names":["Transform","require","bom_utf8","Buffer","from","Stringifier","constructor","opts","writableObjectMode","options","err","opt","underscore","normalize","record_delimiter","state","stop","info","records","bom","push","undefined","CsvError","JSON","stringify","delimiter","isBuffer","toString","quote","quoted","quoted_empty","quoted_match","Array","isArray","isString","isRegExp","RegExp","Error","quoted_string","eof","escape","length","header","columns","normalize_columns","cast","bigint","value","boolean","date","getTime","number","object","string","_transform","chunk","encoding","callback","Object","keys","headers","emit","_flush","chunkIsHeader","record","splice","i","field","__cast","index","column","get","key","csvrecord","isObject","containsdelimiter","indexOf","containsQuote","containsEscape","containsRecordDelimiter","quotedString","quotedMatch","filter","test","shouldQuote","regexp","replace","map","context","type","Date","newcolumns","k","data","arguments","argument","stringifier","chunks","on","read","join","setImmediate","write","end","code","message","contexts","captureStackTrace","parse","module","exports","obj","str","_","match","toLowerCase","charCodeOfDot","charCodeAt","reEscapeChar","rePropName","reIsDeepProp","reIsPlainProp","getTag","prototype","call","isKey","isSymbol","stringToPath","result","expression","subString","trim","castPath","toKey","INFINITY","path"],"mappings":"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","sourcesContent":["\n/*\nCSV Stringify\n\nPlease look at the [project documentation](https://csv.js.org/stringify/) for\nadditional information.\n*/\n\nconst { Transform } = require('stream')\nconst bom_utf8 = Buffer.from([239, 187, 191])\n\nclass Stringifier extends Transform {\n  constructor(opts = {}){\n    super({...{writableObjectMode: true}, ...opts})\n    const options = {}\n    let err\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    if(err = this.normalize(options)) throw err\n    switch(options.record_delimiter){\n      case 'auto':\n        options.record_delimiter = null\n        break\n      case 'unix':\n        options.record_delimiter = \"\\n\"\n        break\n      case 'mac':\n        options.record_delimiter = \"\\r\"\n        break\n      case 'windows':\n        options.record_delimiter = \"\\r\\n\"\n        break\n      case 'ascii':\n        options.record_delimiter = \"\\u001e\"\n        break\n      case 'unicode':\n        options.record_delimiter = \"\\u2028\"\n        break\n    }\n    // Expose options\n    this.options = options\n    // Internal state\n    this.state = {\n      stop: false\n    }\n    // Information\n    this.info = {\n      records: 0\n    }\n    if(options.bom === true){\n      this.push(bom_utf8)\n    }\n    this\n  }\n  normalize(options){\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', [\n        'option `bom` is optional and must be a boolean value,',\n        `got ${JSON.stringify(options.bom)}`\n      ])\n    }\n    // Normalize option `delimiter`\n    if(options.delimiter === undefined || options.delimiter === null){\n      options.delimiter = ','\n    }else if(Buffer.isBuffer(options.delimiter)){\n      options.delimiter = options.delimiter.toString()\n    }else if(typeof options.delimiter !== 'string'){\n      return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', [\n        'option `delimiter` must be a buffer or a string,',\n        `got ${JSON.stringify(options.delimiter)}`\n      ])\n    }\n    // Normalize option `quote`\n    if(options.quote === undefined || options.quote === null){\n      options.quote = '\"'\n    }else if(options.quote === true){\n      options.quote = '\"'\n    }else if(options.quote === false){\n      options.quote = ''\n    }else if (Buffer.isBuffer(options.quote)){\n      options.quote = options.quote.toString()\n    }else if(typeof options.quote !== 'string'){\n      return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', [\n        'option `quote` must be a boolean, a buffer or a string,',\n        `got ${JSON.stringify(options.quote)}`\n      ])\n    }\n    // Normalize option `quoted`\n    if(options.quoted === undefined || options.quoted === null){\n      options.quoted = false\n    }else{\n      // todo\n    }\n    // Normalize option `quoted_empty`\n    if(options.quoted_empty === undefined || options.quoted_empty === null){\n      options.quoted_empty = undefined\n    }else{\n      // todo\n    }\n    // Normalize option `quoted_match`\n    if(options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false){\n      options.quoted_match = null\n    }else if(!Array.isArray(options.quoted_match)){\n      options.quoted_match = [options.quoted_match]\n    }\n    if(options.quoted_match){\n      for(let quoted_match of options.quoted_match){\n        const isString = typeof quoted_match === 'string'\n        const isRegExp = quoted_match instanceof RegExp\n        if(!isString && !isRegExp){\n          return Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)\n        }\n      }\n    }\n    // Normalize option `quoted_string`\n    if(options.quoted_string === undefined || options.quoted_string === null){\n      options.quoted_string = false\n    }else{\n      // todo\n    }\n    // Normalize option `eof`\n    if(options.eof === undefined || options.eof === null){\n      options.eof = true\n    }else{\n      // todo\n    }\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === null){\n      options.escape = '\"'\n    }else if(Buffer.isBuffer(options.escape)){\n      options.escape = options.escape.toString()\n    }else if(typeof options.escape !== 'string'){\n      return Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)\n    }\n    if (options.escape.length > 1){\n      return Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)\n    }\n    // Normalize option `header`\n    if(options.header === undefined || options.header === null){\n      options.header = false\n    }else{\n      // todo\n    }\n    // Normalize option `columns`\n    options.columns = this.normalize_columns(options.columns)\n    // Normalize option `quoted`\n    if(options.quoted === undefined || options.quoted === null){\n      options.quoted = false\n    }else{\n      // todo\n    }\n    // Normalize option `cast`\n    if(options.cast === undefined || options.cast === null){\n      options.cast = {}\n    }else{\n      // todo\n    }\n    // Normalize option cast.bigint\n    if(options.cast.bigint === undefined || options.cast.bigint === null){\n      // Cast boolean to string by default\n      options.cast.bigint = value => '' + value\n    }\n    // Normalize option cast.boolean\n    if(options.cast.boolean === undefined || options.cast.boolean === null){\n      // Cast boolean to string by default\n      options.cast.boolean = value => value ? '1' : ''\n    }\n    // Normalize option cast.date\n    if(options.cast.date === undefined || options.cast.date === null){\n      // Cast date to timestamp string by default\n      options.cast.date = value => '' + value.getTime()\n    }\n    // Normalize option cast.number\n    if(options.cast.number === undefined || options.cast.number === null){\n      // Cast number to string using native casting by default\n      options.cast.number = value => '' + value\n    }\n    // Normalize option cast.object\n    if(options.cast.object === undefined || options.cast.object === null){\n      // Stringify object as JSON by default\n      options.cast.object = value => JSON.stringify(value)\n    }\n    // Normalize option cast.string\n    if(options.cast.string === undefined || options.cast.string === null){\n      // Leave string untouched\n      options.cast.string = function(value){return value}\n    }\n    // Normalize option `record_delimiter`\n    if(options.record_delimiter === undefined || options.record_delimiter === null){\n      options.record_delimiter = '\\n'\n    }else if(Buffer.isBuffer(options.record_delimiter)){\n      options.record_delimiter = options.record_delimiter.toString()\n    }else if(typeof options.record_delimiter !== 'string'){\n      return Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)\n    }\n  }\n  _transform(chunk, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    // Chunk validation\n    if(!Array.isArray(chunk) && typeof chunk !== 'object'){\n      this.state.stop = true\n      return callback(Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`))\n    }\n    // Detect columns from the first record\n    if(this.info.records === 0){\n      if(Array.isArray(chunk)){\n        if(this.options.header === true && !this.options.columns){\n          this.state.stop = true\n          return callback(Error('Undiscoverable Columns: header option requires column option or object records'))\n        }\n      }else if(this.options.columns === undefined || this.options.columns === null){\n        this.options.columns = this.normalize_columns(Object.keys(chunk))\n      }\n    }\n    // Emit the header\n    if(this.info.records === 0){\n      this.headers()\n    }\n    // Emit and stringify the record if an object or an array\n    try{\n      this.emit('record', chunk, this.info.records)\n    }catch(err){\n      this.state.stop = true\n      return this.emit('error', err)\n    }\n    // Convert the record into a string\n    if(this.options.eof){\n      chunk = this.stringify(chunk)\n      if(chunk === undefined){\n        return\n      }else{\n        chunk = chunk + this.options.record_delimiter\n      }\n    }else{\n      chunk = this.stringify(chunk)\n      if(chunk === undefined){\n        return\n      }else{\n        if(this.options.header || this.info.records){\n          chunk = this.options.record_delimiter + chunk\n        }\n      }\n    }\n    // Emit the csv\n    this.info.records++\n    this.push(chunk)\n    callback()\n    null\n  }\n  _flush(callback){\n    if(this.info.records === 0){\n      this.headers()\n    }\n    callback()\n    null\n  }\n  stringify(chunk, chunkIsHeader=false){\n    if(typeof chunk !== 'object'){\n      return chunk\n    }\n    const {columns, header} = this.options\n    const record = []\n    // Record is an array\n    if(Array.isArray(chunk)){\n      // We are getting an array but the user has specified output columns. In\n      // this case, we respect the columns indexes\n      if(columns){\n        chunk.splice(columns.length)\n      }\n      // Cast record elements\n      for(let i=0; i<chunk.length; i++){\n        const field = chunk[i]\n        const [err, value] = this.__cast(field, {\n          index: i, column: i, records: this.info.records, header: chunkIsHeader\n        })\n        if(err){\n          this.emit('error', err)\n          return\n        }\n        record[i] = [value, field]\n      }\n    // Record is a literal object\n    }else{\n      if(columns){\n        for(let i=0; i<columns.length; i++){\n          const field = get(chunk, columns[i].key)\n          const [err, value] = this.__cast(field, {\n            index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader\n          })\n          if(err){\n            this.emit('error', err)\n            return\n          }\n          record[i] = [value, field]\n        }\n      }else{\n        for(let column of chunk){\n          const field = chunk[column]\n          const [err, value] = this.__cast(field, {\n            index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader\n          })\n          if(err){\n            this.emit('error', err)\n            return\n          }\n          record.push([value, field])\n        }\n      }\n    }\n    let csvrecord = ''\n    for(let i=0; i<record.length; i++){\n      let options, err\n      let [value, field] = record[i]\n      if(typeof value === \"string\"){\n        options = this.options\n      }else if(isObject(value)){\n        // let { value, ...options } = value\n        options = value\n        value = options.value\n        delete options.value\n        if(typeof value !== \"string\" && value !== undefined && value !== null){\n          this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`))\n          return\n        }\n        options = {...this.options, ...options}\n        if(err = this.normalize(options)){\n          this.emit(\"error\", err)\n          return\n        }\n      }else if(value === undefined || value === null){\n        options = this.options\n      }else{\n        this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`))\n        return\n      }\n      const {delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter} = options\n      if(value){\n        if(typeof value !== 'string'){\n          this.emit(\"error\", Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`))\n          return null\n        }\n        const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0\n        const containsQuote = (quote !== '') && value.indexOf(quote) >= 0\n        const containsEscape = value.indexOf(escape) >= 0 && (escape !== quote)\n        const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0\n        const quotedString = quoted_string && typeof field === 'string'\n        let quotedMatch = quoted_match && quoted_match.filter( quoted_match => {\n          if(typeof quoted_match === 'string'){\n            return value.indexOf(quoted_match) !== -1\n          }else{\n            return quoted_match.test(value)\n          }\n        })\n        quotedMatch = quotedMatch && quotedMatch.length > 0\n        const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch\n        if(shouldQuote === true && containsEscape === true){\n          const regexp = escape === '\\\\'\n          ? new RegExp(escape + escape, 'g')\n          : new RegExp(escape, 'g')\n          value = value.replace(regexp, escape + escape)\n        }\n        if(containsQuote === true){\n          const regexp = new RegExp(quote,'g')\n          value = value.replace(regexp, escape + quote)\n        }\n        if(shouldQuote === true){\n          value = quote + value + quote\n        }\n        csvrecord += value\n      }else if(quoted_empty === true || (field === '' && quoted_string === true && quoted_empty !== false)){\n        csvrecord += quote + quote\n      }\n      if(i !== record.length - 1){\n        csvrecord += delimiter\n      }\n    }\n    return csvrecord\n  }\n  headers(){\n    if(this.options.header === false){\n      return\n    }\n    if(this.options.columns === undefined){\n      return\n    }\n    let headers = this.options.columns.map(column => column.header)\n    if(this.options.eof){\n      headers = this.stringify(headers, true) + this.options.record_delimiter\n    }else{\n      headers = this.stringify(headers)\n    }\n    this.push(headers)\n  }\n  __cast(value, context){\n    const type = typeof value\n    try{\n      if(type === 'string'){ // Fine for 99% of the cases\n        return [undefined, this.options.cast.string(value, context)]\n      }else if(type === 'bigint'){\n        return [undefined, this.options.cast.bigint(value, context)]\n      }else if(type === 'number'){\n        return [undefined, this.options.cast.number(value, context)]\n      }else if(type === 'boolean'){\n        return [undefined, this.options.cast.boolean(value, context)]\n      }else if(value instanceof Date){\n        return [undefined, this.options.cast.date(value, context)]\n      }else if(type === 'object' && value !== null){\n        return [undefined, this.options.cast.object(value, context)]\n      }else{\n        return [undefined, value, value]\n      }\n    }catch(err){\n      return [err]\n    }\n  }\n  normalize_columns(columns){\n    if(columns === undefined || columns === null){\n      return undefined\n    }\n    if(typeof columns !== 'object'){\n      throw Error('Invalid option \"columns\": expect an array or an object')\n    }\n    if(!Array.isArray(columns)){\n      const newcolumns = []\n      for(let k in columns){\n        newcolumns.push({\n          key: k,\n          header: columns[k]\n        })\n      }\n      columns = newcolumns\n    }else{\n      const newcolumns = []\n      for(let column of columns){\n        if(typeof column === 'string'){\n          newcolumns.push({\n            key: column,\n            header: column\n          })\n        }else if(typeof column === 'object' && column !== undefined && !Array.isArray(column)){\n          if(!column.key){\n            throw Error('Invalid column definition: property \"key\" is required')\n          }\n          if(column.header === undefined){\n            column.header = column.key\n          }\n          newcolumns.push(column)\n        }else{\n          throw Error('Invalid column definition: expect a string or an object')\n        }\n      }\n      columns = newcolumns\n    }\n    return columns\n  }\n}\n\nconst stringify = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (Array.isArray(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ])\n    }\n  }\n  const stringifier = new Stringifier(options)\n  if(callback){\n    const chunks = []\n    stringifier.on('readable', function(){\n      let chunk\n      while((chunk = this.read()) !== null){\n        chunks.push(chunk)\n      }\n    })\n    stringifier.on('error', function(err){\n      callback(err)\n    })\n    stringifier.on('end', function(){\n      callback(undefined, chunks.join(''))\n    })\n  }\n  if(data !== undefined){\n    // Give a chance for events to be registered later\n    if(typeof setImmediate === 'function'){\n      setImmediate(function(){\n        for(let record of data){\n          stringifier.write(record)\n        }\n        stringifier.end()\n      })\n    }else{\n      for(let record of data){\n        stringifier.write(record)\n      }\n      stringifier.end()\n    }\n  }\n  return stringifier\n}\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ')\n    super(message)\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError)\n    }\n    this.code = code\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key]\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value))\n      }\n    }\n  }\n}\n\nstringify.Stringifier = Stringifier\n\nstringify.CsvError = CsvError\n\nmodule.exports = stringify\n\nconst isObject = function(obj){\n  return typeof obj === 'object' && obj !== null && ! Array.isArray(obj)\n}\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase()\n  })\n}\n\n// Lodash implementation of `get`\n\nconst charCodeOfDot = '.'.charCodeAt(0)\nconst reEscapeChar = /\\\\(\\\\)?/g\nconst rePropName = RegExp(\n  // Match anything that isn't a dot or bracket.\n  '[^.[\\\\]]+' + '|' +\n  // Or match property names within brackets.\n  '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n  ')\\\\]'+ '|' +\n  // Or match \"\" as the space between consecutive dots or empty brackets.\n  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n, 'g')\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/\nconst reIsPlainProp = /^\\w*$/\nconst getTag = function(value){\n  if(!value)\n    value === undefined ? '[object Undefined]' : '[object Null]'\n  return Object.prototype.toString.call(value)\n}\nconst isKey = function(value, object){\n  if(Array.isArray(value)){\n    return false\n  }\n  const type = typeof value\n  if(type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)){\n    return true\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object))\n}\nconst isSymbol = function(value){\n  const type = typeof value\n  return type === 'symbol' || (type === 'object' && value && getTag(value) === '[object Symbol]')\n}\nconst stringToPath = function(string){\n  const result = []\n  if(string.charCodeAt(0) === charCodeOfDot){\n    result.push('')\n  }\n  string.replace(rePropName, function(match, expression, quote, subString){\n    let key = match\n    if(quote){\n      key = subString.replace(reEscapeChar, '$1')\n    }else if(expression){\n      key = expression.trim()\n    }\n    result.push(key)\n  })\n  return result\n}\nconst castPath = function(value, object){\n  if(Array.isArray(value)){\n    return value\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value)\n  }\n}\nconst toKey = function(value){\n  if(typeof value === 'string' || isSymbol(value))\n    return value\n  const result = `${value}`\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result\n}\nconst get = function(object, path){\n  path = castPath(path, object)\n  let index = 0\n  const length = path.length\n  while(object != null && index < length){\n    object = object[toKey(path[index++])]\n  }\n  return (index && index === length) ? object : undefined\n}\n"]},"metadata":{},"sourceType":"script"}